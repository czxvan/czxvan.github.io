<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"czxvan.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="创建一个 Linux 内核模块，为 kernel PWN 的学习补充一些基础知识。 英文原文链接：  Kernel modules — The Linux Kernel documentation (linux-kernel-labs.github.io)  代码带库：  linux-kernel-labs&#x2F;linux: Linux kernel source tree (github.">
<meta property="og:type" content="article">
<meta property="og:title" content="Create a Linux Kernel Module">
<meta property="og:url" content="https://czxvan.github.io/2023/10/17/LearningNotes/Create-a-Linux-Kernel-Module/index.html">
<meta property="og:site_name" content="czxvan&#39;s blog">
<meta property="og:description" content="创建一个 Linux 内核模块，为 kernel PWN 的学习补充一些基础知识。 英文原文链接：  Kernel modules — The Linux Kernel documentation (linux-kernel-labs.github.io)  代码带库：  linux-kernel-labs&#x2F;linux: Linux kernel source tree (github.">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-17T10:15:09.000Z">
<meta property="article:modified_time" content="2023-10-18T16:40:24.656Z">
<meta property="article:author" content="czxvan">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://czxvan.github.io/2023/10/17/LearningNotes/Create-a-Linux-Kernel-Module/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://czxvan.github.io/2023/10/17/LearningNotes/Create-a-Linux-Kernel-Module/","path":"2023/10/17/LearningNotes/Create-a-Linux-Kernel-Module/","title":"Create a Linux Kernel Module"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Create a Linux Kernel Module | czxvan's blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">czxvan's blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">理论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">内核模块概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.</span> <span class="nav-text">内核模块示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">1.3.</span> <span class="nav-text">编译内核模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.4.</span> <span class="nav-text">内核模块的加载和卸载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95"><span class="nav-number">1.5.</span> <span class="nav-text">内核模块调试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#objdump"><span class="nav-number">1.5.1.</span> <span class="nav-text">objdump</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#addr2line"><span class="nav-number">1.5.2.</span> <span class="nav-text">addr2line</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#minicom"><span class="nav-number">1.5.3.</span> <span class="nav-text">minicom</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netconsole"><span class="nav-number">1.5.4.</span> <span class="nav-text">netconsole</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Printk-%E8%B0%83%E8%AF%95"><span class="nav-number">1.5.5.</span> <span class="nav-text">Printk 调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dyndbg-%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95"><span class="nav-number">1.5.6.</span> <span class="nav-text">dyndbg 动态调试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E9%80%89%E9%A1%B9"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">动态调试选项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KDB%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%99%A8"><span class="nav-number">1.5.7.</span> <span class="nav-text">KDB内核调试器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">2.</span> <span class="nav-text">练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%86%E5%A4%87"><span class="nav-number">2.0.1.</span> <span class="nav-text">基本准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="nav-number">2.0.2.</span> <span class="nav-text">启动虚拟机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97"><span class="nav-number">2.0.3.</span> <span class="nav-text">内核模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Printk"><span class="nav-number">2.0.4.</span> <span class="nav-text">Printk</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Error"><span class="nav-number">2.0.5.</span> <span class="nav-text">Error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sub-modules"><span class="nav-number">2.0.6.</span> <span class="nav-text">Sub-modules</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kernel-oops"><span class="nav-number">2.0.7.</span> <span class="nav-text">Kernel oops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Module-parameters"><span class="nav-number">2.0.8.</span> <span class="nav-text">Module parameters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proc-info"><span class="nav-number">2.0.9.</span> <span class="nav-text">proc info</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">czxvan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://czxvan.github.io/2023/10/17/LearningNotes/Create-a-Linux-Kernel-Module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="czxvan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="czxvan's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Create a Linux Kernel Module | czxvan's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Create a Linux Kernel Module
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-17 18:15:09" itemprop="dateCreated datePublished" datetime="2023-10-17T18:15:09+08:00">2023-10-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-10-19 00:40:24" itemprop="dateModified" datetime="2023-10-19T00:40:24+08:00">2023-10-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/linux-kernel-labs/" itemprop="url" rel="index"><span itemprop="name">linux-kernel-labs</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>创建一个 <code>Linux</code> 内核模块，为 <code>kernel PWN</code> 的学习补充一些基础知识。</p>
<p>英文原文链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/labs/kernel_modules.html">Kernel modules — The Linux Kernel documentation (linux-kernel-labs.github.io)</a></li>
</ul>
<p>代码带库：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/linux-kernel-labs/linux">linux-kernel-labs&#x2F;linux: Linux kernel source tree (github.com)</a></li>
</ul>
<span id="more"></span>

<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="内核模块概述"><a href="#内核模块概述" class="headerlink" title="内核模块概述"></a>内核模块概述</h2><p>宏内核虽然比微内核要快，但模块化不足，可扩展性低。在现代宏内核中，通过引入内核模块机制，这个问题被很好地解决了。一个内核模块（或者叫可加载内核层）是一个包含可执行指令的对象文件，在需要时被加载，从而达到在运行时扩展内核功能的目的。当不再需要这个内核模块时，可以把它卸载掉。大部分设备驱动以内核模块的形式被使用。</p>
<p>对于<code>Linux</code>设备驱动的开发，一般建议既下载内核源码、配置并编译，同时下载编译好的版本，以便进行测试和开发。</p>
<h2 id="内核模块示例"><a href="#内核模块示例" class="headerlink" title="内核模块示例"></a>内核模块示例</h2><p>下面是一个非常简单的内核模块示例。当被加载到内核中时，它会生成一个消息 “HI”，当被从卸载时，会生成一个消息 “Bye”。</p>
<blockquote>
<p>译者注：模块文件名称不能是 module，本文使用 modul</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;My kernel module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Me&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dummy_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Hi\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dummy_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dummy_init);</span><br><span class="line">module_exit(dummy_exit);</span><br></pre></td></tr></table></figure>

<p>生成的消息不会在终端中展示，而是会被保存到一个特殊的内存区域，我们可以使用日志守护进程 <code>syslog</code> 获取它们。为了展示内核消息，可以使用 <code>dmesg</code> 命令或者查看系统日志。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dmesg | <span class="built_in">tail</span> -2</span></span><br><span class="line">Hi</span><br><span class="line">Bye</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /var/log/syslog | <span class="built_in">tail</span> -2</span></span><br><span class="line">Feb 20 13:57:38 asgard kernel: Hi</span><br><span class="line">Feb 20 13:57:43 asgard kernel: Bye</span><br></pre></td></tr></table></figure>

<h2 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h2><p>编译内核模块和编译用户程序有所不同。首先，要使用一些不同的头文件，且模块不应该链接到任何的库。同时，不能不提的是，模块编译选项必须和目标内核编译时用的选项保持一致。出于这些原因，我们可以使用一个标准的内核模块编译方法（kbuild）。这种方法使用到两个文件：一个 <code>Makefile</code> 和一个 <code>Kbuild</code> 文件。</p>
<p>下面是一个 <code>Makefile</code> 的示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">KDIR = /lib/modules/`uname -r`/build</span><br><span class="line"><span class="comment"># 译者注：这样得到的内核源码目录不一定正确，还需根据实际情况进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="section">kbuild:</span></span><br><span class="line">        make -C <span class="variable">$(KDIR)</span> M=`pwd`</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C <span class="variable">$(KDIR)</span> M=`pwd` clean</span><br></pre></td></tr></table></figure>

<p>一个 <code>Kbuild</code> 示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTRA_CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line">obj-m        = modul.o</span><br></pre></td></tr></table></figure>

<p>正如所见，对 <code>Makefile</code> 调用 <code>make</code>会导致在内核源码目录（KDIR）中调用 <code>make</code>，并引用当前目录（M&#x3D;<code>pwd</code>）。这个过程最终导致从当前目录中读取 <code>Kbuild</code> 文件，并按照该文件中的指示编译模块。</p>
<blockquote>
<p>Note.</p>
<p>当使用从其他地方下载来的Linux源码，而不是本机源码时，需调整 KDIR 至对应内核源码目录。</p>
<p>如：KDIR &#x3D; &#x2F;home&#x2F;student&#x2F;src&#x2F;linux</p>
</blockquote>
<p><code>Kbuild</code> 文件中包含一条或多条用于编译内核模块的指令，最简单的指令示例如：obj-m &#x3D; module.o  根据这条指令，一个内核模块（内核对象ko - kernel object），会从 <code>module.o</code>文件开始创建。<code>module.o</code> 会从 <code>module.c</code> 或 <code>module.S</code> 文件中读取。这些文件都应能在 <code>Kbuild</code> 所在目录中找到。</p>
<p>一个使用多个子模块的 <code>Kbuild</code> 文件示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXTRA_CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line">obj-m = supermodule.o</span><br><span class="line">supermodule-y = module-a.o module-b.o</span><br></pre></td></tr></table></figure>

<p>对于上面的示例，编译步骤如下：</p>
<ul>
<li>编译 <code>module-a.c</code> 和 <code>module-b.c</code> 源码文件，得到 <code>module-a.c</code> 和 <code>module-b.o</code> 对象文件</li>
<li>将 <code>module-a.c</code> 和 <code>module-b.o</code> 链接成 <code>supermodule.o</code></li>
<li>最后从 <code>supermodule.o</code> 可以创建 <code>supermodule.ko</code> 模块</li>
</ul>
<p><code>Kbuild</code> 中目标名称的后缀，决定了它们会被如何使用，规则如下：</p>
<ul>
<li><p>M（module）指可加载内核模块目标</p>
</li>
<li><p>Y（yes）表示一个编译得到的，且还会被链接到内核模块（$(module_name)-y）或链接进内核（obj-y）的对象目标</p>
</li>
<li><p>所有其它的目标名称后缀。都会被 <code>Kbuild</code>忽略，且对应文件不会被编译。</p>
</li>
</ul>
<blockquote>
<p>Note.</p>
<p>这些后缀可以方便使用<code>make menuconfig</code>命令或直接编辑<code>.config</code>文件配置内核。<code>.config</code>文件设置了一系列变量，用于确定在构建时将哪些功能添加到内核中。</p>
<p>例如，当使用<code>make menuconfig</code>添加<code>BTRFS</code>支持时，会将<code>CONFIG BTRFS FS=y</code>行添加到<code>.config</code>文件中。原本<code>BTRFS kbuild</code>包含行<code>obj-$（CONFIG BTRFS FS）：=BTRFS.o</code>，现在该行会变为<code>obj-y：=BTRFS.</code>o。这将编译<code>BTRFS.0</code>对象并将其链接到内核。在设置变量之前，该行变为<code>obj:=btrfs.o</code>，因此它被忽略，构建得到的内核也就不支持<code>BTRFS </code>。</p>
</blockquote>
<h2 id="内核模块的加载和卸载"><a href="#内核模块的加载和卸载" class="headerlink" title="内核模块的加载和卸载"></a>内核模块的加载和卸载</h2><p>加载模块使用<code>insmod</code>命令，接收内核模块路径作参数；卸载模块使用<code>rmmod</code>命令，使用模块名称作为参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">insmod modul.ko</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rmmod modul.ko</span></span><br></pre></td></tr></table></figure>

<p>加载内核模块时，会执行被指定为<code>module_init</code>宏参数的例程。类似地，当卸载模块时，会执行被指定为<code>module_exit</code>宏参数的例程。</p>
<p>一个内核模块完整的编译、加载、卸载的过程如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">faust:~/lab-01/modul-lin# ls</span><br><span class="line">Kbuild  Makefile  modul.c</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# make</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=`pwd`</span><br><span class="line">make[1]: Entering directory `/usr/src/linux-2.6.28.4&#x27;</span><br><span class="line">  LD      /root/lab-01/modul-lin/built-in.o</span><br><span class="line">  CC [M]  /root/lab-01/modul-lin/modul.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /root/lab-01/modul-lin/modul.mod.o</span><br><span class="line">  LD [M]  /root/lab-01/modul-lin/modul.ko</span><br><span class="line">make[1]: Leaving directory `/usr/src/linux-2.6.28.4&#x27;</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# ls</span><br><span class="line">built-in.o  Kbuild  Makefile  modul.c  Module.markers</span><br><span class="line">modules.order  Module.symvers  modul.ko  modul.mod.c</span><br><span class="line">modul.mod.o  modul.o</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# insmod modul.ko</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# dmesg | tail -1</span><br><span class="line">Hi</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# rmmod modul</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# dmesg | tail -2</span><br><span class="line">Hi</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>

<p>已加载模块的信息，可以通过<code>lsmod</code>命令进行查看，也可以通过 <code>/proc/modules</code>文件 和 <code>/sys/module</code>目录进行查看。</p>
<h2 id="内核模块调试"><a href="#内核模块调试" class="headerlink" title="内核模块调试"></a>内核模块调试</h2><p>对内核模块进行故障排除比调试常规程序要复杂得多。首先，内核模块中的错误可能导致整个系统阻塞，因此故障排除也就慢很多。为了避免重启，推荐使用虚拟机（如qemu，virtualbox，vmware等）。</p>
<p>当一个包含<code>bug</code>的内核模块被加载到内核中时，最终会生成一个内核<code>oops</code>。内核<code>oops</code>是内核检测到的无效操作，只能由内核产生。对于稳定的内核版本，<code>oops</code>的产生几乎可以肯定地意味着内核模块中存在<code>bug</code>。在<code>oops</code>出现后，内核会继续工作。</p>
<p>保存<code>oops</code>出现时内核发出的消息是很重要的，和上面提到的一样，内核产生的消息被保存到日志中，能够使用<code>dmesg</code>命令进行展示。为了不丢失任何的内核消息，推荐直接从控制台终端插入&#x2F;测试内核模块，或者定期查看内核消息。值得注意的是，<code>oops</code>的产生既可能是因为一个编程错误，也可能是因为一个错误。</p>
<p>如果出现一个致命的错误，导致系统无法返回到一个稳定态，会产生一个内核<code>panic</code>。</p>
<p>下面是一个包含bug，会产生<code>oops</code>的内核模块源码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Oops generating kernel module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION (<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">MODULE_LICENSE (<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR (<span class="string">&quot;PSO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP_READ         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP_WRITE        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP_OOPS         OP_WRITE</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_oops_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *a;</span><br><span class="line"></span><br><span class="line">        a = (<span class="type">int</span> *) <span class="number">0x00001234</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OP_OOPS == OP_WRITE</span></span><br><span class="line">        *a = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OP_OOPS == OP_READ</span></span><br><span class="line">        printk (KERN_ALERT <span class="string">&quot;value = %d\n&quot;</span>, *a);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unknown op for oops!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_oops_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init (my_oops_init);</span><br><span class="line">module_exit (my_oops_exit);</span><br></pre></td></tr></table></figure>

<p>将这个模块插入到内核中时，会产生一个<code>oops</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">faust:~/lab<span class="number">-01</span>/modul-oops<span class="meta"># insmod oops.ko</span></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">faust:~/lab<span class="number">-01</span>/modul-oops<span class="meta"># dmesg | tail -32</span></span><br><span class="line">BUG: unable to handle kernel paging request at <span class="number">00001234</span></span><br><span class="line">IP: [&lt;c89d4005&gt;] my_oops_init+<span class="number">0x5</span>/<span class="number">0x20</span> [oops]</span><br><span class="line">  *de = <span class="number">00000000</span></span><br><span class="line">Oops: <span class="number">0002</span> [#<span class="number">1</span>] PREEMPT DEBUG_PAGEALLOC</span><br><span class="line">last sysfs file: /sys/devices/virtual/net/lo/operstate</span><br><span class="line">Modules linked in: oops(+) netconsole ide_cd_mod pcnet32 crc32 cdrom [last unloaded: modul]</span><br><span class="line"></span><br><span class="line">Pid: <span class="number">4157</span>, comm: insmod Not tainted (<span class="number">2.6</span><span class="number">.28</span><span class="number">.4</span> #<span class="number">2</span>) VMware Virtual Platform</span><br><span class="line">EIP: <span class="number">0060</span>:[&lt;c89d4005&gt;] EFLAGS: <span class="number">00010246</span> CPU: <span class="number">0</span></span><br><span class="line">EIP is at my_oops_init+<span class="number">0x5</span>/<span class="number">0x20</span> [oops]</span><br><span class="line">EAX: <span class="number">00000000</span> EBX: fffffffc ECX: c89d4300 EDX: <span class="number">00000001</span></span><br><span class="line">ESI: c89d4000 EDI: <span class="number">00000000</span> EBP: c5799e24 ESP: c5799e24</span><br><span class="line"> DS: <span class="number">007b</span> ES: <span class="number">007b</span> FS: <span class="number">0000</span> GS: <span class="number">0033</span> SS: <span class="number">0068</span></span><br><span class="line">Process insmod (pid: <span class="number">4157</span>, ti=c5799000 task=c665c780 task.ti=c5799000)</span><br><span class="line">Stack:</span><br><span class="line"> c5799f8c c010102d c72b51d8 <span class="number">0000000</span>c c5799e58 c01708e4 <span class="number">00000124</span> <span class="number">00000000</span></span><br><span class="line"> c89d4300 c5799e58 c724f448 <span class="number">00000001</span> c89d4300 c5799e60 c0170981 c5799f8c</span><br><span class="line"> c014b698 <span class="number">00000000</span> <span class="number">00000000</span> c5799f78 c5799f20 <span class="number">00000500</span> c665cb00 c89d4300</span><br><span class="line">Call Trace:</span><br><span class="line"> [&lt;c010102d&gt;] ? _stext+<span class="number">0x2d</span>/<span class="number">0x170</span></span><br><span class="line"> [&lt;c01708e4&gt;] ? __vunmap+<span class="number">0xa4</span>/<span class="number">0xf0</span></span><br><span class="line"> [&lt;c0170981&gt;] ? vfree+<span class="number">0x21</span>/<span class="number">0x30</span></span><br><span class="line"> [&lt;c014b698&gt;] ? load_module+<span class="number">0x19b8</span>/<span class="number">0x1a40</span></span><br><span class="line"> [&lt;c035e965&gt;] ? __mutex_unlock_slowpath+<span class="number">0xd5</span>/<span class="number">0x140</span></span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+<span class="number">0x106</span>/<span class="number">0x150</span></span><br><span class="line"> [&lt;c014b7aa&gt;] ? sys_init_module+<span class="number">0x8a</span>/<span class="number">0x1b0</span></span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+<span class="number">0x106</span>/<span class="number">0x150</span></span><br><span class="line"> [&lt;c0240a08&gt;] ? trace_hardirqs_on_thunk+<span class="number">0xc</span>/<span class="number">0x10</span></span><br><span class="line"> [&lt;c0103407&gt;] ? sysenter_do_call+<span class="number">0x12</span>/<span class="number">0x43</span></span><br><span class="line">Code: &lt;c7&gt; <span class="number">05</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">5</span>d c3 eb <span class="number">0</span>d <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line">EIP: [&lt;c89d4005&gt;] my_oops_init+<span class="number">0x5</span>/<span class="number">0x20</span> [oops] SS:ESP <span class="number">0068</span>:c5799e24</span><br><span class="line">---[ end trace <span class="number">2981</span>ce73ae801363 ]---</span><br></pre></td></tr></table></figure>

<p>尽管相对神秘，内核给出的消息提供了出现<code>oops</code>错误的重要信息。第一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BUG: unable to handle kernel paging request at 00001234</span><br><span class="line">EIP: [&lt;c89d4005&gt;] my_oops_init + 0x5 / 0x20 [oops]</span><br></pre></td></tr></table></figure>

<p>告诉我们产生错误的原因，和造成错误的指令的地址。本例中，这是一个无效内存地址获取。</p>
<p>下一行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Oops: 0002 [# 1] PREEMPT DEBUG_PAGEALLOC</span><br></pre></td></tr></table></figure>

<p>告诉我们这是第一个<code>oops</code>(#1)，在一个<code>oops</code>可能导致其它<code>oops</code>时，这一点是很重要的。通常，我们要关注的是第一个<code>oops</code>。此外，<code>oops code</code>（0002）标明了错误类型（见<code>arch/x86/include/asm/trap_pf.h</code>）：</p>
<ul>
<li>Bit 0 &#x3D;&#x3D; 0 表示找不到页，1 表示页保护错误</li>
<li>Bit 1 &#x3D;&#x3D; 0 表示读，1 表示写</li>
<li>Bit 2 &#x3D;&#x3D; 0 表示内核模式，1 表示用户模式</li>
</ul>
<p>在本例中，产生<code>oops</code>(Bit 1 &#x3D;&#x3D; 1)的原因是，尝试在<code>内核模式</code>向一个<code>找不到的内存页</code>执行<code>写操作</code>。</p>
<p>下面使用<code>dmesg</code>产看日志，可以看到寄存器的转储信息，给出了<code>EIP</code>寄存器的值，同时可以注意到<code>bug</code>出现在<code>my_oops_init</code>函数，偏移为5字节(<code>EIP: [&lt;c89d4005&gt;] my_oops_init+0x5</code>)（译者注：？），同时消息还展示了堆栈内容和在<code>oops</code>出现前的调用回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">faust:~/lab-01/modul-oops# dmesg | tail -33</span><br><span class="line">BUG: unable to handle kernel paging request at 00001234</span><br><span class="line">IP: [&lt;c89c3016&gt;] my_oops_init+0x6/0x20 [oops]</span><br><span class="line">  *de = 00000000</span><br><span class="line">Oops: 0000 [#1] PREEMPT DEBUG_PAGEALLOC</span><br><span class="line">last sysfs file: /sys/devices/virtual/net/lo/operstate</span><br><span class="line">Modules linked in: oops(+) netconsole pcnet32 crc32 ide_cd_mod cdrom</span><br><span class="line"></span><br><span class="line">Pid: 2754, comm: insmod Not tainted (2.6.28.4 #2) VMware Virtual Platform</span><br><span class="line">EIP: 0060:[&lt;c89c3016&gt;] EFLAGS: 00010292 CPU: 0</span><br><span class="line">EIP is at my_oops_init+0x6/0x20 [oops]</span><br><span class="line">EAX: 00000000 EBX: fffffffc ECX: c89c3380 EDX: 00000001</span><br><span class="line">ESI: c89c3010 EDI: 00000000 EBP: c57cbe24 ESP: c57cbe1c</span><br><span class="line"> DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068</span><br><span class="line">Process insmod (pid: 2754, ti=c57cb000 task=c66ec780 task.ti=c57cb000)</span><br><span class="line">Stack:</span><br><span class="line"> c57cbe34 00000282 c57cbf8c c010102d c57b9280 0000000c c57cbe58 c01708e4</span><br><span class="line"> 00000124 00000000 c89c3380 c57cbe58 c5db1d38 00000001 c89c3380 c57cbe60</span><br><span class="line"> c0170981 c57cbf8c c014b698 00000000 00000000 c57cbf78 c57cbf20 00000580</span><br><span class="line">Call Trace:</span><br><span class="line"> [&lt;c010102d&gt;] ? _stext+0x2d/0x170</span><br><span class="line"> [&lt;c01708e4&gt;] ? __vunmap+0xa4/0xf0</span><br><span class="line"> [&lt;c0170981&gt;] ? vfree+0x21/0x30</span><br><span class="line"> [&lt;c014b698&gt;] ? load_module+0x19b8/0x1a40</span><br><span class="line"> [&lt;c035d083&gt;] ? printk+0x0/0x1a</span><br><span class="line"> [&lt;c035e965&gt;] ? __mutex_unlock_slowpath+0xd5/0x140</span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+0x106/0x150</span><br><span class="line"> [&lt;c014b7aa&gt;] ? sys_init_module+0x8a/0x1b0</span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+0x106/0x150</span><br><span class="line"> [&lt;c0240a08&gt;] ? trace_hardirqs_on_thunk+0xc/0x10</span><br><span class="line"> [&lt;c0103407&gt;] ? sysenter_do_call+0x12/0x43</span><br><span class="line">Code: &lt;a1&gt; 34 12 00 00 c7 04 24 54 30 9c c8 89 44 24 04 e8 58 a0 99 f7 31</span><br><span class="line">EIP: [&lt;c89c3016&gt;] my_oops_init+0x6/0x20 [oops] SS:ESP 0068:c57cbe1c</span><br><span class="line">---[ end trace 45eeb3d6ea8ff1ed ]---</span><br></pre></td></tr></table></figure>

<p>如果生成一个无效的读调用(<code>#define OP_OOPS OP_READ</code>)，消息基本会是相同的，但是<code>oops code</code>会变成 <code>0000</code>。</p>
<h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>使用<code>objdump</code>工具，可以获得导致<code>oops</code>的指令的详细信息。常用指令有两个，<code>-d</code>用于反汇编，<code>-S</code>用于交织显示<code>C</code>代码和汇编代码，一般组合使用<code>-dS</code>。为了提高解码效率，我们需要用到内核模块的加载地址，它可以在<code>/proc/modules</code>中找到。</p>
<p>下面是一个示例，对上面的内核模块使用<code>objdump</code>命令，识别生成<code>oops</code>的指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">faust:~/lab-01/modul-oops# cat /proc/modules</span><br><span class="line">oops 1280 1 - Loading 0xc89d4000</span><br><span class="line">netconsole 8352 0 - Live 0xc89ad000</span><br><span class="line">pcnet32 33412 0 - Live 0xc895a000</span><br><span class="line">ide_cd_mod 34952 0 - Live 0xc8903000</span><br><span class="line">crc32 4224 1 pcnet32, Live 0xc888a000</span><br><span class="line">cdrom 34848 1 ide_cd_mod, Live 0xc886d000</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-oops# objdump -dS --adjust-vma=0xc89d4000 oops.ko</span><br><span class="line"></span><br><span class="line">oops.ko:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">c89d4000 &lt;init_module&gt;:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_READ         0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_WRITE        1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_OOPS         OP_WRITE</span></span><br><span class="line"></span><br><span class="line">static int my_oops_init (void)</span><br><span class="line">&#123;</span><br><span class="line">c89d4000:       55                      push   %ebp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error <span class="string">&quot;Unknown op for oops!&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">c89d4001:       31 c0                   xor    %eax,%eax</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_READ         0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_WRITE        1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_OOPS         OP_WRITE</span></span><br><span class="line"></span><br><span class="line">static int my_oops_init (void)</span><br><span class="line">&#123;</span><br><span class="line">c89d4003:       89 e5                   mov    %esp,%ebp</span><br><span class="line">        int *a;</span><br><span class="line"></span><br><span class="line">        a = (int *) 0x00001234;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> OP_OOPS == OP_WRITE</span></span><br><span class="line">        *a = 3;</span><br><span class="line">c89d4005:       c7 05 34 12 00 00 03    movl   $0x3,0x1234</span><br><span class="line">c89d400c:       00 00 00</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error <span class="string">&quot;Unknown op for oops!&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">c89d400f:       5d                      pop    %ebp</span><br><span class="line">c89d4010:       c3                      ret</span><br><span class="line">c89d4011:       eb 0d                   jmp    c89c3020 &lt;cleanup_module&gt;</span><br><span class="line">c89d4013:       90                      nop</span><br><span class="line">c89d4014:       90                      nop</span><br><span class="line">c89d4015:       90                      nop</span><br><span class="line">c89d4016:       90                      nop</span><br><span class="line">c89d4017:       90                      nop</span><br><span class="line">c89d4018:       90                      nop</span><br><span class="line">c89d4019:       90                      nop</span><br><span class="line">c89d401a:       90                      nop</span><br><span class="line">c89d401b:       90                      nop</span><br><span class="line">c89d401c:       90                      nop</span><br><span class="line">c89d401d:       90                      nop</span><br><span class="line">c89d401e:       90                      nop</span><br><span class="line">c89d401f:       90                      nop</span><br><span class="line"></span><br><span class="line">c89d4020 &lt;cleanup_module&gt;:</span><br><span class="line"></span><br><span class="line">static void my_oops_exit (void)</span><br><span class="line">&#123;</span><br><span class="line">c89d4020:       55                      push   %ebp</span><br><span class="line">c89d4021:       89 e5                   mov    %esp,%ebp</span><br><span class="line">&#125;</span><br><span class="line">c89d4023:       5d                      pop    %ebp</span><br><span class="line">c89d4024:       c3                      ret</span><br><span class="line">c89d4025:       90                      nop</span><br><span class="line">c89d4026:       90                      nop</span><br><span class="line">c89d4027:       90                      nop</span><br></pre></td></tr></table></figure>

<p>可以看到，上面得到的造成<code>oops</code>的指令的地址（c89d4005）处的内容是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C89d4005: c7 05 34 12 00 00 03 movl $ 0x3,0x1234</span><br></pre></td></tr></table></figure>

<p>这正是我们期望的——在<code>0x0001234</code>处存储<code>3</code>。</p>
<p><code>/proc/modules</code>中包含内核模块的加载地址，<code>--adjust-vma</code>选项允许我们展示和<code>0xc89d4000</code>相关的指令。</p>
<p><code>-l</code>选项展示插入到汇编代码中的<code>C</code>源码的行号。</p>
<h3 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h3><p>一个更简单地找到造成<code>oops</code>的指令的方式，是使用<code>addr2line</code>工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">faust:~/lab-01/modul-oops# addr2line -e oops.o 0x5</span><br><span class="line">/root/lab-01/modul-oops/oops.c:23</span><br></pre></td></tr></table></figure>

<p>其中<code>0x5</code>是生成<code>oops</code>的指令的程序计数（<code>EIP=c89d4005</code>）减去模块加载基址（0xc89d4000，可在<code>/proc/modules</code>中查看）后的值。</p>
<h3 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h3><p><code>minicom</code>（或其他等效程序，如 <code>picocom</code>, <code>screen</code>），是一个能够用于连接串行端口并与之交互的工具。使用串行端口实在开发阶段分析内核消息或与嵌入式系统进行交互的基本方法。有两种常见的连接方式：</p>
<ul>
<li>我们将使用的设备的<strong>串行端口</strong>是<code>/dev/ttyS0</code></li>
<li>我们将使用的设备的<code>USB</code>端口（FTDI）是<code>/dev/ttyUSB</code></li>
</ul>
<p>如果使用虚拟机，虚拟机启动时会显示我们使用的设备。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char device redirected to /dev/pts/20 (label virtiocon0)</span><br></pre></td></tr></table></figure>

<p><code>minicom</code>使用示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用COM1连接，115,200比特率</span></span><br><span class="line">minicom -b 115200 -D /dev/ttyS0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">USB串行端口连接</span></span><br><span class="line">minicom -D /dev/ttyUSB0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接虚拟机的串行端口</span></span><br><span class="line">minicom -D /dev/pts/20</span><br></pre></td></tr></table></figure>

<h3 id="netconsole"><a href="#netconsole" class="headerlink" title="netconsole"></a>netconsole</h3><p><code>netconsole</code>是一个可以使用<strong>网络</strong>打印内核日志消息的工具，当磁盘日志系统无法工作、串行端口无法使用或终端没有回显时，使用<code>netconsole</code>很合适。<code>netconsole</code>本身以内核模块的形式存在。</p>
<p>工作时需要以下参数：</p>
<ul>
<li>端口@IP 地址&#x2F;调试站的源接口名称</li>
<li>端口@调试消息被发送到的机器的 IP 地址&#x2F;MAC 地址</li>
</ul>
<p>这些参数可以在模块被<strong>插入内核时</strong>进行配置，也可以在<strong>模块插入后</strong>进行配置（要求编译时开启了 <code>CONFIG_NETCONSOLE_DYNAMIC</code> 选项）。</p>
<p>将<code>netconsole</code>插入内核时的一个配置示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alice:~# modprobe netconsole netconsole=6666@192.168.191.130/eth0,6000@192.168.191.1/00:50:56:c0:00:08</span><br></pre></td></tr></table></figure>

<p>IP 地址为<code>192.168.191.130</code>的源机器上的调试信息，会经过<code>6666</code>端口上的<code>eth0</code>接口，发送到 IP 地址为<code>192.168.191.1</code> MAC 地址为<code>00:50:56:c0:00:08</code>的目标机器的<code>6000</code>端口。</p>
<p>在目标机器上可以使用<code>netcat</code>接收消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob:~ # nc -l -p 6000 -u</span><br></pre></td></tr></table></figure>

<p>或者，目标机器上可以配置<code>syslogd</code>来拦截这些消息。更多信息可在<code>Documentation/networking/netconsole.txt</code>中找到。</p>
<h3 id="Printk-调试"><a href="#Printk-调试" class="headerlink" title="Printk 调试"></a>Printk 调试</h3><blockquote>
<p>两个最经典、最有用的调试工具是你的大脑和 Printf。</p>
</blockquote>
<p>对于调试，大家经常使用一种原始但非常高效的方式：<code>printk</code>调试。尽管可以使用调试器，但它通常不是很有用：简单的<code>bug</code>（比如未初始化的变量，内存管理问题等）可以通过控制消息打印或观察解码后的内核<code>oops</code>信息快速定位。</p>
<p>对于更复杂的<code>bug</code>，即便是调试器也没办法给予我们太多帮助，除非操作系统的结构非常好理解。当调试内核模块时，存在很多位置的因素：多个上下文（同一时刻系统里运行着多个进程和线程），中断，虚拟内存等等。</p>
<p>你可以使用<code>printk</code>把内核消息展示到用户空间。它和<code>printf</code>的功能相似，唯一的区别是，传输的消息可以以字符串”<code>&lt;n&gt;</code>“为前缀，其中<code>n</code>表示错误级别（日志级别），值的范围是<code>0-7</code>。如果不使用”<code>&lt;n&gt;</code>“，也可以使用一些符号常量表示日志级别，对应关系如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n = 0	KERN_EMERG</span><br><span class="line">n = 1	KERN_ALERT</span><br><span class="line">n = 2	KERN_CRIT</span><br><span class="line">n = 3	KERN_ERR</span><br><span class="line">n = 4	KERN_WARNING</span><br><span class="line">n = 5	KERN_NOTICE</span><br><span class="line">n = 6	KERN_INFO</span><br><span class="line">n = 7	KERN_DEBUG</span><br></pre></td></tr></table></figure>

<p>关于所有日志级别的定义，可以在<code>linux/kern_levels.h</code>文件中找到。基本上，这些级别主要用于告诉系统要把消息发送到哪里：终端，日志文件，或者 <code>/var/log</code> 等等。</p>
<blockquote>
<p>Note.</p>
<p>为了在用户空间展示<code>printk</code>消息，消息的日志级别必须比<code>console_loglevel </code>的级别要高（数值要小）。默认的终端日志级别可以在<code>/proc/sys/kernel/printk</code>进行配置。</p>
<p>比如，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">echo</span> 8 &gt; /proc/sys/kernel/printk</span></span><br></pre></td></tr></table></figure>

<p>以上命令将使得所有内核日志消息都能够在终端中展示。也就是说，日志记录级别必须严格小于<code>console_loglevel</code>变量。例如，如果<code>console_loglevel</code>的值为 5（<code>KERN_NOTICE</code>），则只显示<code>loglevel&lt;=5</code>的消息（即KERN_EMERG、KERN_ALERT、KERN_CRIT、KERN_ERR、KERN_WARNING）。</p>
</blockquote>
<p>控制台重定向消息对于快速查看执行内核代码的效果非常有用，但如果内核遇到无法修复的错误并且系统冻结，它们就不再那么有用了。</p>
<p>在这种情况下，必须查阅系统的日志，因为它们在系统重新启动之间保留信息。这些文件位于<code>/var/log</code>中，是文本文件，在内核运行期间由<code>syslogd</code>和<code>klogd</code>填充。<code>syslogd</code>和<code>klogd</code>从装载的<code>/proc</code>虚拟文件系统中获取信息。原则上，打开<code>syslogd</code>和<code>klogd</code>后，所有来自内核的消息都将转到<code>/var/log/kern.log</code>。</p>
<p>一个更简单的调试方法是使用<code>/var/log/debug</code>文件。它只由来自内核的具有<code>KERN_DEBUG</code>日志级别的printk消息填充。</p>
<p>考虑到生产内核（类似于我们可能正在运行的内核）只包含<strong>发布代码</strong>，我们的模块是少数几个发送以<code>KERN DEBUG</code>为前缀的消息的模块之一。通过这种方式，我们可以通过查找与模块的调试会话相对应的消息，轻松地浏览<code>/var/log/debug</code>信息。</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clear the debug file of previous information (or possibly a backup)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;New debug session&quot;</span> &gt; /var/log/debug</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the tests</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If there is no critical error causing a panic kernel, check the output</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> a critical error occurs and the machine only responds to a restart,</span></span><br><span class="line">  restart the system and check /var/log/debug.</span><br></pre></td></tr></table></figure>

<p>为了检测错误，打印出的消息应当尽量包含所有感兴趣的信息，但在代码中插入<code>printk</code>可能与编写解决问题的代码一样耗时。因此通常需要是调试消息完整性和将这些消息插入代码所需时间之间进行权衡。</p>
<p>可以使用预定义的常量<code>__FILE__</code>, <code>__LINE__</code> and <code>__func__</code>来提高插入<code>printk</code>语句的效率：</p>
<ul>
<li><p><code>__FILE__</code>被编译器替换为<strong>源文件</strong>的名称</p>
</li>
<li><p><code>__LINE__</code>被编译器替换为当前指令对应的源文件中代码的<strong>行号</strong></p>
</li>
<li><p><code>__func__/__FUNCTION__</code>被编译器替换为当前指令<strong>所在函数</strong>的名称</p>
</li>
</ul>
<blockquote>
<p>Note.</p>
<p><code>__FILE__</code>和<code>__LINE__</code>是<code>ANSI C</code>规范的一部分：<code>__func_</code>是<code>C99</code>规范的一部分；<code>__FUNCTION __</code>是一个<code>GNU C</code>扩展，不可移植；不过，由于我们为<code>Linux</code>内核编写代码，因此可以毫无问题地使用它们。</p>
</blockquote>
<p>下面的<strong>宏定义</strong>可以在这样的情况下使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define PRINT_DEBUG \</span></span><br><span class="line"><span class="language-bash">       printk (KERN_DEBUG <span class="string">&quot;[% s]: FUNC:% s: LINE:% d \ n&quot;</span>, __FILE__,</span></span><br><span class="line">               __FUNCTION__, __LINE__)</span><br></pre></td></tr></table></figure>

<p>之后，在每个我们想要观察是否执行到的位置，插入<code>PRINT_DEBUG</code>即可。这是一个简单快速的方式，且可以用于仔细的分系。</p>
<p><code>dmesg</code>命令被用来观察使用<code>printk</code>打印，但未在终端输出的消息。</p>
<p>运行以下命令，可以删除日志文件中之前的消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/null &gt; /var/log/debug</span><br></pre></td></tr></table></figure>

<p>运行以下命令，可以删除当前能被<code>dmesg</code>输出的消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg -c</span><br></pre></td></tr></table></figure>

<h3 id="dyndbg-动态调试"><a href="#dyndbg-动态调试" class="headerlink" title="dyndbg 动态调试"></a>dyndbg 动态调试</h3><p>动态调试能够显著地减少要输出的消息的数量。为了使用动态调试函数，编译内核时要开启<code>CONFIG_DYNAMIC_DEBUG</code>选项，之后就可以使用<code>pr_debug()</code>, <code>dev_dbg()</code>, <code>print_hex_dump_debug()</code>, <code>print_hex_dump_bytes()</code>等函数。</p>
<p>当<code>debugfs</code>被挂载到<code>/sys/kernel/debug</code>时，<code>/sys/kernel/debug/dynamic_debug/control</code>文件用于过滤消息，也可以通过它查看已经存在的过滤器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t debugfs none /debug</span><br></pre></td></tr></table></figure>

<p><code>Debugfs</code>是一个简单的文件系统，用作内核空间接口和用户空间接口来配置不同的调试选项。任何调试工具都可以在<code>debugfs</code>中创建和使用自己的文件&#x2F;文件夹。</p>
<p>比如，为了展示动态调试（dyndbg）中已经存在的过滤器，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p>如郭想要接收<code>svsock.c</code>文件的第<strong>1603</strong>行输出的调试消息，可以使用以下命令进行设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;file svcsock.c line 1603 +p&#x27; &gt; /debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<h4 id="动态调试选项"><a href="#动态调试选项" class="headerlink" title="动态调试选项"></a>动态调试选项</h4><ul>
<li><p>func - 根据所在函数的函数名过滤消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;func svc_tcp_accept +p&#x27; &gt; /debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>
</li>
<li><p>file - 根据源文件名过滤消息，可以使用绝对路径和相对路径，以及内核树路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file svcsock.c</span><br><span class="line">file kernel/freezer.c</span><br><span class="line">file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>module - 根据模块名过滤消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module sunrpc</span><br></pre></td></tr></table></figure>
</li>
<li><p>format - 只显示包含以下字符串的消息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">format &quot;nfsd: SETATTR&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>line - 根据行号启用调试函数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Triggers debug messages between lines 1603 and 1605 <span class="keyword">in</span> the svcsock.c file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;file svcsock.c line 1603-1605 +p&#x27;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enables debug messages from the beginning of the file to line 1605</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;file svcsock.c line -1605 +p&#x27;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>除了以上选项，还可以使用操作符（<code>+</code> <code> -</code> <code> =</code>）添加、删除或设置一系列<code>flags</code></p>
<ul>
<li>p  激活<code>pr_debug()</code></li>
<li>f 在输出消息中包含函数名</li>
<li>l 在输出消息中包含行号</li>
<li>m 在输出消息中包含模块名</li>
<li>t 在输出消息中包含线程 id ，如果不是从中断上下文中调用的话</li>
<li>_ 不设置任何标志</li>
</ul>
<h3 id="KDB内核调试器"><a href="#KDB内核调试器" class="headerlink" title="KDB内核调试器"></a>KDB内核调试器</h3><p>内核调试器已被证明对促进开发和调试过程非常有用。它的主要优点之一是可以执行实时调试。这使我们能够实时监控对内存的访问，甚至在调试时修改内存。从<code>2.6.26-rci</code>版本开始，调试器已经集成在主流内核中。KDB不是源调试器，但要进行完整的分析，它可以并行使用<code>gdb</code>和符号文件——请参阅<a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/so2/lab1-intro.html#gdb-intro">gdb调试部分</a></p>
<p>要使用<code>KDB</code>，有以下选项：</p>
<ul>
<li><p>非<code>usb</code>键盘+<code>VGA</code>文本控制台</p>
</li>
<li><p>串行端口控制台</p>
</li>
<li><p><code>USB EHCI</code>调试端口</p>
</li>
</ul>
<p>对于本实验，我们将使用连接到主机的串行接口。以下命令将通过串行端口激活GDB：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc</span><br></pre></td></tr></table></figure>

<p><code>KDB</code>是一个<code>stop</code>模式调试器，这意味着当它处于活动状态时，所有其他进程都会停止。在执行过程中，可以使用以下<code>Sys Rq</code>命令强制内核进入<code>KDB</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo g &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>

<p>或者通过在连接到串行端口（例如使用minicom）的终端中使用组合键<code>Ctrl+O g</code>。</p>
<p>KDB有各种命令来控制和定义被调试系统的上下文：</p>
<ul>
<li><p>lsmod、ps、kill、dmesg、env、bt（backtrace，回溯）</p>
</li>
<li><p>转储跟踪日志</p>
</li>
<li><p>硬件断点</p>
</li>
<li><p>修改内存</p>
</li>
</ul>
<p>为了更好地描述可用的命令，可以使用<code>KDBshell</code>中的<code>help</code>命令。在下一个示例中，您可以注意到一个简单的<code>KDB</code>使用示例，它设置了一个硬件断点来监视<code>mVar</code>变量的更改</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">trigger KDB</span></span><br><span class="line">echo g &gt; /proc/sysrq-trigger</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or <span class="keyword">if</span> we are connected to the serial port issue</span></span><br><span class="line">Ctrl-O g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">breakpoint on write access to the mVar variable</span></span><br><span class="line"><span class="meta prompt_">kdb&gt; </span><span class="language-bash">bph mVar dataw</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">return</span> from KDB</span></span><br><span class="line"><span class="meta prompt_">kdb&gt; </span><span class="language-bash">go</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note.</p>
<p>如果你想学习如何轻松浏览Linux源代码以及如何调试内核代码，请阅读“<a target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/so2/lab1-intro.html#good-to-know">Good to know</a> ”部分。</p>
</blockquote>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h3 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h3><p>下载内核源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.98.tar.xz</span><br><span class="line">unxz linux-5.4.98.tar.xz</span><br><span class="line">tar -xf linux-5.4.98.tar</span><br></pre></td></tr></table></figure>

<p>配置编译选项，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项Compile the kernel with debug info，以便于调试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要使用 kgdb 调试内核，则需要选中 KGDB: kernel debugger，并选中 KGDB 下的所有选项。</span></span><br></pre></td></tr></table></figure>

<p>根据配置准备必要文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make prepare</span><br></pre></td></tr></table></figure>

<p>创建内核模块实验目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir linuxkm</span><br><span class="line">code linuxkm  # 使用vscode</span><br></pre></td></tr></table></figure>

<p>设置vscode 头文件目录，添加以下三个路径，如果头文件仍然显示错误，建议禁用错误波形曲线</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/linux-5.4.98/include/**</span><br><span class="line">~/linux-5.4.98/arch/x86/include/**</span><br><span class="line">&quot;~/linux-5.4.98/arch/x86/include/generated/**&quot;</span><br></pre></td></tr></table></figure>

<p>Makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">KDIR =  ~/linux-5.4.98/</span><br><span class="line"></span><br><span class="line"><span class="section">kbuild:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=`pwd`</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=`pwd` clean</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: kbuild clean</span></span><br></pre></td></tr></table></figure>

<p>Kbuild</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTRA_CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line">obj-m        = modul.o</span><br></pre></td></tr></table></figure>

<p>modul.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;My kernel module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Me&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dummy_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Hi\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dummy_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dummy_init);</span><br><span class="line">module_exit(dummy_exit);</span><br></pre></td></tr></table></figure>

<p>执行make命令，输出以下内容则编译成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">~/linuxkm$ </span><span class="language-bash">make</span></span><br><span class="line">make -C ~/linux-5.4.98/ M=`pwd`</span><br><span class="line">make[1]: Entering directory &#x27;/home/czx/linux-5.4.98&#x27;</span><br><span class="line">  CC [M]  /mnt/d/Users/czx/NativeFiles/Desktop/PWN/linuxkm/modul.o</span><br><span class="line"></span><br><span class="line">  WARNING: Symbol version dump ./Module.symvers</span><br><span class="line">           is missing; modules will have no dependencies and modversions.</span><br><span class="line"></span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC [M]  /mnt/d/Users/czx/NativeFiles/Desktop/PWN/linuxkm/modul.mod.o</span><br><span class="line">  LD [M]  /mnt/d/Users/czx/NativeFiles/Desktop/PWN/linuxkm/modul.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/home/czx/linux-5.4.98&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行 make boot</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">tools/labs$ </span><span class="language-bash">make boot</span></span><br><span class="line">qemu/create_net.sh lkt-tap0</span><br><span class="line">qemu/create_net.sh lkt-tap1</span><br><span class="line">/home/czx/linux-kernel-labs/tools/labs/templates/assignments/6-e100/nttcp -v -i &amp;</span><br><span class="line">nttcp-l: nttcp, version 1.47</span><br><span class="line">nttcp-l: running in inetd mode on port 5037 - ignoring options beside -v and -p</span><br><span class="line">bind: Address already in use</span><br><span class="line">nttcp-l: service-socket: bind:: Address already in use, errno=98</span><br><span class="line">ARCH=x86 qemu/qemu.sh -kernel /home/czx/linux-kernel-labs/arch/x86/boot/bzImage -device virtio-serial -chardev pty,id=virtiocon0 -device virtconsole,chardev=virtiocon0 -serial pipe:pipe1 -serial pipe:pipe2 -netdev tap,id=lkt-tap0,ifname=lkt-tap0,script=no,downscript=no -net nic,netdev=lkt-tap0,model=virtio -netdev tap,id=lkt-tap1,ifname=lkt-tap1,script=no,downscript=no -net nic,netdev=lkt-tap1,model=i82559er -drive file=core-image-minimal-qemux86.ext4,if=virtio,format=raw -drive file=disk1.img,if=virtio,format=raw -drive file=disk2.img,if=virtio,format=raw --append &quot;root=/dev/vda loglevel=15 console=hvc0 pci=noacpi&quot; --display none -s -m 256</span><br><span class="line">char device redirected to /dev/pts/9 (label virtiocon0)</span><br></pre></td></tr></table></figure>

<p>使用 minicom 登录qemu，注意 -D 后的设备号与上面输出的最后一行保持一致，进入时输入root，即获得shell界面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">minicom -D /dev/pts/9</span><br><span class="line">或</span><br><span class="line">minicom -D serial.pts</span><br></pre></td></tr></table></figure>

<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><h3 id="Printk"><a href="#Printk" class="headerlink" title="Printk"></a>Printk</h3><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><h3 id="Sub-modules"><a href="#Sub-modules" class="headerlink" title="Sub-modules"></a>Sub-modules</h3><h3 id="Kernel-oops"><a href="#Kernel-oops" class="headerlink" title="Kernel oops"></a>Kernel oops</h3><h3 id="Module-parameters"><a href="#Module-parameters" class="headerlink" title="Module parameters"></a>Module parameters</h3><h3 id="proc-info"><a href="#proc-info" class="headerlink" title="proc info"></a>proc info</h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/10/17/else/Create-a-Blog-with-Hexo/" rel="prev" title="Create a Blog with Hexo">
                  <i class="fa fa-angle-left"></i> Create a Blog with Hexo
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/19/Windwos-PWN/Exploitme/Exploitme1/" rel="next" title="Exploitme1——栈上执行Shellcode">
                  Exploitme1——栈上执行Shellcode <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">czxvan</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
